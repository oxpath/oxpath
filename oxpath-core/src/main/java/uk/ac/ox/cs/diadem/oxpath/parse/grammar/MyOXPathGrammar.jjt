
/**
 * JJTree template file for specifying the OXPath script parser
 * @author Giovanni Grasso <gio@oxpath.org>
 */
options
{
  NODE_CLASS="uk.ac.ox.cs.diadem.oxpath.parse.ast.custom.CustomSimpleNode";
  STATIC=false;
  MULTI=true;
  VISITOR=true;
  VISITOR_EXCEPTION="uk.ac.ox.cs.diadem.oxpath.utils.OXPathException";
//  VISITOR_RETURN_TYPE="OXPathType";
  OUTPUT_DIRECTORY="..";
  JJTREE_OUTPUT_DIRECTORY="../ast";
  NODE_PACKAGE="uk.ac.ox.cs.diadem.oxpath.parse.ast";
  JDK_VERSION = "1.5";
  LOOKAHEAD = 1;
  UNICODE_INPUT=true;
  //JAVA_UNICODE_ESCAPE = true;
//  IGNORE_CASE =true;
}

PARSER_BEGIN(OXPathParser)
package uk.ac.ox.cs.diadem.oxpath.parse;

import java.io.FileReader;
import java.io.Reader;
import java.lang.StringBuilder;

import java.io.StringReader;

import java.util.ArrayList;
import java.util.Deque;
import java.util.ArrayDeque;

import uk.ac.ox.cs.diadem.oxpath.core.ActionKeywords;

import uk.ac.ox.cs.diadem.oxpath.utils.OXPathException;
import uk.ac.ox.cs.diadem.oxpath.utils.PrintVisitor;
import uk.ac.ox.cs.diadem.oxpath.model.language.functions.XPathFunction;
import uk.ac.ox.cs.diadem.oxpath.model.language.functions.XPathFunctions;

import uk.ac.ox.cs.diadem.oxpath.model.language.operators.HigherLevelOp;
import uk.ac.ox.cs.diadem.oxpath.model.language.operators.EqualityExprOp;
import uk.ac.ox.cs.diadem.oxpath.model.language.operators.RelationalExprOp;
import uk.ac.ox.cs.diadem.oxpath.model.language.operators.AdditiveExprOp;
import uk.ac.ox.cs.diadem.oxpath.model.language.operators.MultiplicativeExprOp;

import uk.ac.ox.cs.diadem.oxpath.model.language.Axis;
import uk.ac.ox.cs.diadem.oxpath.model.language.ForwardAxis;
import uk.ac.ox.cs.diadem.oxpath.model.language.BackwardAxis;
import uk.ac.ox.cs.diadem.oxpath.model.language.OXPathAxis;
import uk.ac.ox.cs.diadem.oxpath.model.language.AbbreviatedAxis;
import uk.ac.ox.cs.diadem.oxpath.model.language.OXPathNodeTest;
import uk.ac.ox.cs.diadem.oxpath.model.language.XPathNodeTest;
import uk.ac.ox.cs.diadem.oxpath.model.language.ParameterizedProcessingInstruction;
import uk.ac.ox.cs.diadem.oxpath.model.language.XPathNameTest;
import uk.ac.ox.cs.diadem.oxpath.model.language.NodeTest;
import uk.ac.ox.cs.diadem.oxpath.model.language.OXPathExtractionMarker;
import uk.ac.ox.cs.diadem.oxpath.model.language.Selector;
import uk.ac.ox.cs.diadem.oxpath.model.language.SelectorPredicate;
import uk.ac.ox.cs.diadem.oxpath.model.language.Action;
import uk.ac.ox.cs.diadem.oxpath.model.language.PositionAction;
import uk.ac.ox.cs.diadem.oxpath.model.language.ExplicitAction;
import uk.ac.ox.cs.diadem.oxpath.model.language.KeywordAction;
import uk.ac.ox.cs.diadem.oxpath.model.language.VariableAction;
import uk.ac.ox.cs.diadem.oxpath.model.language.URLAction;
import uk.ac.ox.cs.diadem.oxpath.model.language.Step;
import uk.ac.ox.cs.diadem.oxpath.model.language.OXPathStep;
import uk.ac.ox.cs.diadem.oxpath.model.language.AbbreviatedStep;
import uk.ac.ox.cs.diadem.oxpath.model.language.MyLocationPath;
import org.apache.commons.lang.mutable.MutableBoolean;

/**
 *OXPath parser autogenerated by javacc
 * @author Giovanni Grasso <gio@oxpath.org>
 */
public class OXPathParser
{
  Deque<MutableBoolean> predicateStack = new ArrayDeque<MutableBoolean>();
  public OXPathParser()
  {

  }

  public static void main(String args [])
  {
    try
    {
      FileReader reader = new FileReader(args[0]);
      OXPathParser oxpathparser = new OXPathParser(reader);
      Node n = oxpathparser.Expression();
    }
    catch (Exception e)
    {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }

  boolean openNewPredicateWatcher() {
   // if (predicateStack.isEmpty()) {
      predicateStack.addFirst(new MutableBoolean());
      return true;
    //}
    //return false;
  }

  boolean closePredicateWatcher() {
    return predicateStack.removeFirst().toBoolean();
  }

void cleanScopeForPredicate(){  int toRemove = jjtree.nodeArity();
          while (toRemove-- > 0) {
            jjtree.popNode();
          }
}
  void setPredicateComplex() {
    // MutableBoolean first = predicateStack.peekFirst();
    // if(first != null)
    // first.setValue(true);

    for (final MutableBoolean mutableBoolean : predicateStack) {
      mutableBoolean.setValue(true);
    }
  }
  
  /**
   * Returns JJTree of script
   */
  public static Node getJJTree(String inputfile) throws OXPathException {
    try {
      FileReader reader = new FileReader(inputfile);
      OXPathParser oxpathparser = new OXPathParser(reader);
      return oxpathparser.Expression();
    } catch (Exception e) {
      throw new OXPathException("Parser exception!",e);
    }
  }

  public static Node getJJTreeFromString(String in) throws OXPathException
  {
    try
    {
      return new OXPathParser(new StringReader(in)).Expression();
    } catch (Exception e)
    {
      throw new OXPathException("Parser Exception!",e);
    }
  }

 public static Node getJJTreeFromReader(Reader in) throws OXPathException
  {
    try
    {
      return new OXPathParser(in).Expression();
    } catch (Exception e)
    {
      throw new OXPathException("Parser Exception!",e);
    }
  }

  public static Node safeGetChild(Node parent, int index) throws OXPathException {
    if (isSafeChild(parent,index))
    {
      return parent.jjtGetChild(index);
    }
    else throw new OXPathException("Not an OXPath AST node!");
  }

  public static boolean isSafeChild(Node parent, int index) {
    if (parent.jjtGetChild(index) instanceof Node)
    {
      return true;
    }
    else
    {
      return false;
    }
  }

  public static boolean hasChildByName(Node parent, String name)
  {
    for (int i = 0; i<parent.jjtGetNumChildren(); i++)
    {
      if (parent.jjtGetChild(i).toString().contains(name))
      {
        return true;
      }
    }
    return false;
  }

  public static boolean hasDescendantOrSelfByName(Node parent, String name) throws OXPathException
  {
    if (parent.toString().contains(name)) return true;
    else
    {
      for (int i = 0; i<parent.jjtGetNumChildren(); i++)
      {
        if (hasDescendantOrSelfByName(parent.jjtGetChild(i),name)) {
          return true;
        }
      }
    }
    return false;
  }

  public static boolean hasActionOnMainPath(Node node)
  {
    if (node.toString().contains("ASTOXPathActionPath")) return true;
    else
    {
      for (int i = 0; i < node.jjtGetNumChildren(); i++)
      {
        Node child = node.jjtGetChild(i);
        if (!child.toString().contains("ASTSimpleOXPathStepPath") && hasActionOnMainPath(child)) return true;
      }
      return false;
    }
  }

  public static Node getChildByName(Node parent, String name) throws OXPathException
  {
    for (int i = 0; i<parent.jjtGetNumChildren(); i++)
    {
      if (parent.jjtGetChild(i).toString().contains(name))
      {
        return safeGetChild(parent,i);
      }
    }
    throw new OXPathException("Child not found!");
  }

  public static int test(String tester)
  {
    System.out.println(tester);
    return 1;
  }

  public static boolean isDescendant(Node a, Node d)
  {
    if (a.equals(d)) return true;
    Node temp = d.jjtGetParent();
    while (!(temp==null))
    {
      if (a.equals(temp)) return true;
      temp = temp.jjtGetParent();
    }
    return false;
  }
}

PARSER_END(OXPathParser)

< IN_URL > TOKEN :
{
  < APOSTROPHE_URL : "'" >
| < QUOTE_URL : "\"" >
}


< DEFAULT , IN_URL , IN_PATH_OP > SKIP :  /* IN-LINE WHITE SPACE*/
{
   <  SPACE :  " " >
|  <  TAB : "\t" >
|  <  NEWLINE : ("\n"|"\r"|"\r\n")>
}

< IN_URL > TOKEN :
{
  < PROTOCOL : "http" ("s")? ":" "/" "/">
}

< ACTION > TOKEN :
{
  < FOCUS : "focus" > : DEFAULT
| < CLICK : "click" > : DEFAULT
| < NEXTCLICK : "nextclick" > : DEFAULT
| < PRESSENTER : "pressenter" > : DEFAULT
| < CLICKWITHCHANGE : "clkwithchange" > : DEFAULT
| < MOVETOFRAME : "movetoframe" > : DEFAULT
| < ENTERFRAME : "enterframe" > : DEFAULT
| < MOVETOHREF : "movetohref" > : DEFAULT
| < DBLCLICK : "dblclick" > : DEFAULT
| < MOUSEDOWN : "mousedown" > : DEFAULT
| < MOUSEENTER : "mouseenter" > : DEFAULT
| < MOUSEMOVE : "mousemove" > : DEFAULT
| < MOUSEOVER : "mouseover" > : DEFAULT
| < MOUSEOUT : "mouseout" > : DEFAULT
| < MOUSEUP : "mouseup" > : DEFAULT
| < WHEEL : "wheel" > : DEFAULT
| < SUBMIT : "submit" > : DEFAULT
//| < UNCLICK : "unclick" > : DEFAULT
| < CHECK : "check" > : DEFAULT
| < UNCHECK : "uncheck" > : DEFAULT
//| < WHILE : "while" >
| < VARIABLE : < DOLLAR > < NCNAME > > : DEFAULT
}

< IN_URL > TOKEN :
{
  < END_URL_IN_PATH : ">" > : DEFAULT
| < END_URL : "}" > : DEFAULT
| < SLASH_URL : "/" >
| < QUESTION_URL : "?" >
| < MINUS_URL : "-" >
| < UNDERSCORE_URL : "_" >
| < PERIOD_URL : "." >
| < AMPERSAND_URL : "&" >
| < EQUALS_URL : "=" >
| < DOLLAR_URL : "$" >
| < PERCENT_URL : "%" >
| < AT_URL : "@" >
| < PLUS_URL : "+" >
| < EXCLAIMATION_URL : "!" >
| < STAR_URL : "*" >
| < OPEN_PARAN_URL : "(" >
| < CLOSE_PARAN_URL : ")" >
| < COMMA_URL : "," >
}

< IN_URL > TOKEN : /* VALUE RETURNS FOR URL Expression */
{
  < LOWER_ALPHA : ["a"-"z"] >
| < UPPER_ALPHA : ["A"-"Z"] >
| < DIGIT : ["0"-"9"] >
}

< DEFAULT, IN_PATH_OP, IN_URL > TOKEN : /* Handling line terminals */
	{
	  < ENDLINE : ";" > : DEFAULT
	}

< DEFAULT > TOKEN :
{
< EQUALS_DEFAULT : "=" > : DEFAULT
}

< DEFAULT , IN_PATH_OP > TOKEN : /* EXPR TOKEN */
{
  < DOC_BEGIN : "doc" ( < SPACE > | < TAB > | < NEWLINE > )* "(" > : DEFAULT
| < OPEN_PARAN : "(" > : DEFAULT
| < CLOSE_PARAN : ")" > : IN_PATH_OP
| < OPEN_OPTIONAL : "[?" > : DEFAULT
| < OPEN_BRACKET : "[" > : DEFAULT
| < CLOSE_BRACKET : "]" > : IN_PATH_OP
| < BEGIN_URL_IN_PATH : "{" ( < SPACE > | < TAB > | < NEWLINE > )* "<" > : IN_URL
| < OPEN_CURLY : "{" > : ACTION
| < CLOSE_CURLY : "}" > :DEFAULT
| < COMMA : "," > : DEFAULT
| < NUMBER : (< DIGITS > "." (< DIGITS >)?) | ("." < DIGITS >) > : IN_PATH_OP//Integers are returned as <DIGITS > tokens
| < DESCENDENT_OR_SELF_SHORT : "/" ( < SPACE > | < TAB > | < NEWLINE > )* "/" > : DEFAULT
| < BEGIN_USER_ACTION :  "/" ( < SPACE > | < TAB > | < NEWLINE > )* "{" > : ACTION
| < BEGIN_KLEENE_STAR :  "/" ( < SPACE > | < TAB > | < NEWLINE > )* "(" > : DEFAULT
| < BEGIN_BOUNDED_KLEENE_STAR_PRED : "*" ( < SPACE > | < TAB > | < NEWLINE > )* "{" > : DEFAULT
| < SLASH : "/" > : DEFAULT
| < BEGIN_EXTRACT_MARK : ":<" > : DEFAULT

}

< DEFAULT > TOKEN : /* EXPR TOKEN */
{
  //OXPath axis names
< STYLE : "style"  ( < SPACE > | < TAB > | < NEWLINE > )* < AXIS > > : DEFAULT
| < ATTRIBUTE : "attribute" ( < SPACE > | < TAB > | < NEWLINE > )* < AXIS > > : DEFAULT
| < CHILD : "child" ( < SPACE > | < TAB > | < NEWLINE > )* < AXIS > > : DEFAULT
| < DESCENDANTORSELF : "descendant-or-self" ( < SPACE > | < TAB > | < NEWLINE > )* < AXIS > > : DEFAULT
| < DESCENDANT : "descendant" ( < SPACE > | < TAB > | < NEWLINE > )* < AXIS > > : DEFAULT
| < FOLLOWINGSIBLING : "following-sibling" ( < SPACE > | < TAB > | < NEWLINE > )* < AXIS > > : DEFAULT
| < FOLLOWING : "following" ( < SPACE > | < TAB > | < NEWLINE > )* < AXIS > > : DEFAULT
| < NAMESPACE : "namespace" ( < SPACE > | < TAB > | < NEWLINE > )* < AXIS > > : DEFAULT
| < SELF : "self" ( < SPACE > | < TAB > | < NEWLINE > )* < AXIS > > : DEFAULT
| < ANCESTORORSELF : "ancestor-or-self" ( < SPACE > | < TAB > | < NEWLINE > )* < AXIS > > : DEFAULT
| < ANCESTOR : "ancestor" ( < SPACE > | < TAB > | < NEWLINE > )* < AXIS > > : DEFAULT
| < PARENT : "parent" ( < SPACE > | < TAB > | < NEWLINE > )* < AXIS > > : DEFAULT
| < PRECEDINGSIBLING : "preceding-sibling" ( < SPACE > | < TAB > | < NEWLINE > )* < AXIS > > : DEFAULT
| < PRECEDING : "preceding" ( < SPACE > | < TAB > | < NEWLINE > )* < AXIS > > : DEFAULT
| < AXIS : "::" > : DEFAULT
| < COMMENT : "comment" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < TEXT : "text" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < PROCESSING_INSTRUCTION : "processing-instruction" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < NODE : "node" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < FIELD : "field" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > >   : DEFAULT
| < ANY_FIELD : "any-field" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > :DEFAULT
| < PERIOD : "." > : IN_PATH_OP
| < PARENT_SHORT : ".." > : IN_PATH_OP
| < AT : "@" > : DEFAULT
| < POSITION : "position" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < LAST : "last" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < COUNT : "count" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < ID : "id" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < NAMESPACEURI : "namespace-uri" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < LOCALNAME : "local-name" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < NAME : "name" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < STRING : "string" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < CONCAT : "concat" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < STARTSWITH : "starts-with" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < CONTAINSFUNC : "contains" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < MINUS_FUNC : "opex:minus" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < PLUS_FUNC : "opex:plus" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < SUBSTRINGBEFORE : "substring-before" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < SUBSTRINGAFTER : "substring-after" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < SUBSTRING : "substring" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < SUBSTRINGLENGTH : "string-length" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < NORMALIZESPACE : "normalize-space" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < TRANSLATE : "translate" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
/* oxpath string processing extensions */
| < SUBSTRINGBEFOREREVERSE : "substring-before-reverse" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < SUBSTRINGAFTERREVERSE : "substring-after-reverse" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < SUBSTRINGREVERSE : "substring-reverse" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
/* new from xpath 2 */
| < STRINGJOIN : "string-join" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < REPLACE : "replace" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < MATCHES : "matches" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
/* oxpath user defined extensions, IMPORTANT: add any new one to the production XPathUserFunctionCallName */
| < QUALIFYURL : "qualify-url" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < ISVISIBLE : "is-visible" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < ISINVISIBLE : "is-invisible" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < TOXML : "to-xml" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < DOMPROPERTY : "dom-property" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < SELECTTEXT : "select-text" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < INNERHTML : "innerhtml" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < OUTERHTML : "outerhtml" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < CURRENTURL : "current-url" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < PAGECONTENT : "page-content" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < SCREENSHOT : "screenshot" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < SAVEPAGE : "save-page" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < NOW : "now" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < URIFY : "urify" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < JAROWRINKLER : "jaro-wrinkler" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT

/* ** */
| < BOOLEAN : "boolean" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < NOT : "not" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < TRUE : "true" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < FALSE : "false" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < LANG : "lang" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < NUMBERFUNC : "number" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < SUM : "sum" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < FLOOR : "floor" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < CEILING : "ceiling" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < ROUND : "round" ( < SPACE > | < TAB > | < NEWLINE > )* < OPEN_PARAN > > : DEFAULT
| < END_EXTRACT_MARK : ">" > : DEFAULT
| < NEGATIVE : "-"> : DEFAULT
}

< IN_PATH_OP > TOKEN : /* EXPR TOKEN */
{
  < AND : "and" > : DEFAULT
| < OR : "or" > : DEFAULT
| < MOD : "mod" > : DEFAULT
| < DIV : "div" > : DEFAULT
| < MULTIPLY : "*" > : DEFAULT
| < UNION : "|" > : DEFAULT
| < PLUS : "+" > : DEFAULT
| < MINUS : "-" > : DEFAULT
| < LESSTE : "<=" > : DEFAULT
| < LESS : "<" > : DEFAULT
| < GREATERTE : ">=" > : DEFAULT
| < GREATER : ">" > : DEFAULT
| < NOTEQUAL : "!=" > : DEFAULT
| < EQUALS : "=" > : DEFAULT
| < PERIOD_OP : "." > : DEFAULT
| < HASH : "#" >   : DEFAULT
| < WORD_TEST : "~=" > : DEFAULT
| < CONTAINS : "#=" > : DEFAULT
}

< DEFAULT, IN_PATH_OP > TOKEN : /* ACTION KEY WORDS */
{
  < WAIT : "wait" ( < SPACE > | < TAB > | < NEWLINE > )* "=" >
| < UNTIL : "until" ( < SPACE > | < TAB > | < NEWLINE > )* "=" >
| < NOBACK : "noback" >
}

< DEFAULT > TOKEN : /*VARIABLE*/
{
  < DOLLAR : "$" > : DEFAULT
}

< DEFAULT > TOKEN : /* NAME_TEST */
{
  < WILDCARD : "*" > : IN_PATH_OP
}

< DEFAULT, IN_PATH_OP > TOKEN : /* NAME_TEST */
{
  < NCNAME : < NAMESTARTCHAR > (< NAMESTARTCHAR > | "-" | ["0"-"9"])* > : IN_PATH_OP//period removed to allow for use of CSS class operator
| < NAMESTARTCHAR : ["A"-"Z"] | ["a"-"z"] | "_" >
| < COLON : ":" >
}

< DEFAULT,ACTION > TOKEN : /* NUMBER */
{
  < DIGITS : (["0"-"9"])+ > : DEFAULT
}

< DEFAULT, ACTION > MORE :
{
< "\"" > : IN_DOUBLE_QUOTE_STRING_PATH
}

< IN_DOUBLE_QUOTE_STRING_PATH >
TOKEN :
{
< DOUBLE_QUOTE_STRING_PATH : "\"" > : IN_PATH_OP
}

< IN_DOUBLE_QUOTE_STRING_PATH >
MORE :
{
< ~["\""] >
}

< DEFAULT, ACTION > MORE :
{
< "'" > : IN_SINGLE_QUOTE_STRING_PATH
}

< IN_SINGLE_QUOTE_STRING_PATH >
TOKEN :
{
< SINGLE_QUOTE_STRING_PATH : "'" > : IN_PATH_OP
}

< IN_SINGLE_QUOTE_STRING_PATH >
MORE :
{
< ~["'"] >
}

//Apparently, we can't get rid of this - the AST needs a fixed root node for JavaCC
Node Expression() :
{}
{
  XPathExpr() < EOF >
  {
    return jjtThis;
  }
}


String Letter() #void:
{Token t;}
{
 ( t = < UPPER_ALPHA > {return t.image;} )
 | ( t = < LOWER_ALPHA > {return t.image;} )
}

String URLName() #void:
{StringBuilder sb = new StringBuilder();
 String sp;
 String hp;
 Token t1;
 String up;
 Token t2;
 String us;}
{//adapted from w3c BNF grammar for BNF located @ http://www.w3.org/Addressing/URL/5_BNF.html#z18
  sp = SupportedProtocols() hp = HostPort() {sb.append(sp); sb.append(hp);}
  [ t1 = < SLASH_URL >  up = URLPath() {sb.append(t1.image); sb.append(up);} ]
  [ t2 = < QUESTION_URL > us = URLSearch() {sb.append(t2.image); sb.append(us);} ]
  {return sb.toString();}
}

String SupportedProtocols() #void:
{Token t;}
{//current supported protocols of http and https
  t = < PROTOCOL >
  {return t.image;}
}

String HostPort() #void:
{StringBuilder sb = new StringBuilder();
 String h;
 Token t;
 int p;}
{
  h = Host() {sb.append(h);} [ t = < COLON > p = Port() {sb.append(t.image); sb.append(p);} ]
  {return sb.toString();}
}

String Host() #void:
{String subtree;}
{
  (subtree = HostName() {return subtree;} )
   | ( subtree = HostNumber() {return subtree;})
}

String HostName() #void:
{String subtree;}
{
  subtree = URLIAlpha() {return subtree;}
}

String URLIAlpha() #void:
{StringBuilder st = new StringBuilder();
 String l;
 String u;}
{
  l=Letter() {st.append(l);} [ u=URLXAlphas() {st.append(u);} ]
  {return st.toString();}
}

String URLXAlphas() #void:
{StringBuilder sb = new StringBuilder();
 String u;
 String us;}
{
 u = URLXAlpha() {sb.append(u);} [ us = URLXAlphas() {sb.append(us);} ]
 {return sb.toString();}
}

String URLXAlpha() #void:
{String s;
 Token t;}
{
	  s=Letter() {return s;}
	| t=< DIGIT > {return t.image;}
	| s=URLSafe() {return s;}
	| s=URLExtra() {return s;}
	| s=URLEscape() {return s;}
}

String URLSafe() #void:
{Token t;}
{
  t=< DOLLAR_URL > {return t.image;}
| t=< MINUS_URL > {return t.image;}
| t=< UNDERSCORE_URL > {return t.image;}
| t=< AT_URL > {return t.image;}
| t=< PERIOD_URL > {return t.image;}
| t=< AMPERSAND_URL > {return t.image;}
| t=< PLUS_URL > {return t.image;}
| t=< EQUALS_URL > {return t.image;}//not part of the grammar; in practice, however, <EQUALS_URL> is URL safe
}

String URLExtra() #void:
{Token t;}
{
  t=< EXCLAIMATION_URL > {return t.image;}
| t=< STAR_URL > {return t.image;}
| t=< QUOTE_URL > {return t.image;}
| t=< APOSTROPHE_URL > {return t.image;}
| t=< OPEN_PARAN_URL > {return t.image;}
| t=< CLOSE_PARAN_URL > {return t.image;}
| t=< COMMA_URL > {return t.image;}

}

String URLEscape() #void:
{Token t;}
{
  t=< PERCENT_URL > {return t.image;}
}

String HostNumber() #void:
{int s1;
 Token t1;
 int s2;
 Token t2;
 int s3;
 Token t3;
 int s4;}
{
  s1=Digits() t1=< PERIOD_URL > s2=Digits() t2=< PERIOD_URL > s3=Digits() t3=< PERIOD_URL > s4=Digits()
  {StringBuilder sb = new StringBuilder();
   sb.append(s1);
   sb.append(t1);
   sb.append(s2);
   sb.append(t2);
   sb.append(s3);
   sb.append(t3);
   sb.append(s4);
   return sb.toString();}
}

int Digits() #void:
{Token t;
 StringBuilder sb = new StringBuilder();}
{
  (
    t=< DIGIT > {sb.append(t.image);}
  )+
  {return Integer.parseInt(sb.toString());}
}

int Port() #void:
{int s;}
{
  s=Digits() {return s;}
}

String URLPath() #void:
{StringBuilder sb = new StringBuilder();
 String s1;
 Token t;
 String s2;}
{
  [s1=URLSegment() {sb.append(s1);} [ t=< SLASH_URL > s2=URLPath() {sb.append(t.image); sb.append(s2);} ]]
  {return sb.toString();}
}

String URLSegment() #void:
{String s;}
{
  s=URLXAlphas() {return s;}
}

String URLSearch() #void:
{String s;}
{
  s=URLXAlphas() {return s;}
}

void OXPathPathSegment() #RelativeOXPathLocationPath://#OXPathPathSegment(>1)://Adapted in part from the grammar in http://www.w3.org/TR/xpath/, adapted to be LL(1)
{}
{//don't support relative location paths for start
  ComplexOXPathStepPath() {jjtThis.setHasComplexPath(true);}
| SimpleOXPathStepPath(null) {jjtThis.setHasSimplePath(true);}  [ComplexOXPathStepPath() {jjtThis.setHasComplexPath(true);}]
| SimpleOXPathStepTail(null) {jjtThis.setIsAbsolutePath(true); jjtThis.setHasSimplePath(true);} [ComplexOXPathStepPath() {jjtThis.setHasComplexPath(true);}]
//| RelativeOXPathLocationTail() {jjtThis.setIsAbsoluteNavigation(true);}
}

void RelativeOXPathLocationPath() :
{}{
  ComplexOXPathStepPath() {jjtThis.setHasComplexPath(true);}
| SimpleOXPathStepPath(null) {jjtThis.setHasSimplePath(true);}  [ComplexOXPathStepPath() {jjtThis.setHasComplexPath(true);}]}

void SimpleOXPathStepTail(MyLocationPath previous) #void:
{}
{  < SLASH > SimpleOXPathStepPath(previous)
| SimpleOXPathDOSStepPath(previous)
{}
}

void SimpleOXPathDOSStepPath(MyLocationPath previous) #SimpleOXPathStepPath(previous==null):
{
  MyLocationPath locationPath;
  if(previous == null)
 	locationPath = new MyLocationPath();
  else locationPath = previous;
}
{  DescendantOrSelfShort()
 { locationPath.appendStep(new OXPathStep(ForwardAxis.DESCENDANTORSELF,XPathNodeTest.NODE));

   if(previous==null) jjtThis.setLocationPath(locationPath);
    
 }
  SimpleOXPathStepPath(locationPath)
  {
   jjtThis.setHasList(locationPath.hasList());
  }
}

void ComplexOXPathStepPath() #void :
{
  setPredicateComplex();}
{  OXPathKleeneStarPath()
| OXPathActionPath()
}

void DescendantOrSelfShort() #void:
{}
{
  < DESCENDENT_OR_SELF_SHORT >
}


void OXPathKleeneStarPath() :
{
 ArrayList<Integer> list;}
{
  //Overload the Multiply operator for Kleene star
  < BEGIN_KLEENE_STAR >   OXPathPathSegment() < CLOSE_PARAN >
  (
    < MULTIPLY > {jjtThis.setHasLowerBound(false);jjtThis.setHasUpperBound(false);} |
    (      < BEGIN_BOUNDED_KLEENE_STAR_PRED > list=OXPathKleeneStarPredicate() < CLOSE_CURLY >
      {if (list.size()>1)      	{jjtThis.setHasLowerBound(true);
      	 jjtThis.setHasUpperBound(true);
      	 jjtThis.setLowerBound(list.get(0));
      	 jjtThis.setUpperBound(list.get(1));}       else {jjtThis.setHasLowerBound(true); jjtThis.setHasUpperBound(false); jjtThis.setLowerBound(list.get(0));}      }
    )
  )

  [ RelativeOXPathLocationTail() {jjtThis.setHasFollowingPath(true);} ]

}

ArrayList<Integer> OXPathKleeneStarPredicate() #void:
{ArrayList<Integer> result = new ArrayList<Integer>();
 int i1;
 int i2;}
{
  i1=OXPathKleeneStarPredicateArg() {result.add(i1);}
  [ <COMMA >
     i2=OXPathKleeneStarPredicateArg() {result.add(i2);} ]
  {return result;}
}

int OXPathKleeneStarPredicateArg() #void:
{Token t;}
{
  t=< DIGITS >
  {return Integer.parseInt(t.image);}
}

void OXPathActionPath() :
{Action action;}
{
	action=OXPathAction() {jjtThis.setAction(action);}
	[ RelativeOXPathLocationTail()   {jjtThis.setHasTail(true);}]
}

void RelativeOXPathLocationTail() #void:
{}
{ ComplexOXPathStepPath()| < SLASH > RelativeOXPathLocationPath()
| AbbreviatedAbsoluteOXPathLocationPath()
}

void SimpleOXPathStepPath(MyLocationPath previousLocationPath) #SimpleOXPathStepPath(createAST):
{
  Step step; 
  boolean createAST = false;
  MyLocationPath currentLocationPath = new MyLocationPath();
  jjtThis.setLocationPath(currentLocationPath);
  MyLocationPath carryOn = null;
 
}
{
  (
    step=FullStep()
  | step=AbbreviatedStep()
  ) {
    if(step.isPlainXPath()){//in this case we can append to an existing location path or start a new one
	
	    if(previousLocationPath == null){//is the first step, append to the new locationpath
	    	createAST=true;
	 		currentLocationPath.appendStep(step);
	 		carryOn=currentLocationPath;
	 	}
	 	else{//we use the one under construction
	 		createAST=false;
	 		previousLocationPath.appendStep(step);
	 		carryOn=previousLocationPath;
	 		//currentLocationPath = previousLocationPath;//here we are sure we only need the previous to carry on
	 	}
    }
    else{//we cannot append the step to the previous (if any), but we need a new AST here
    	jjtThis.setIsPlainXPath(false);
 		currentLocationPath.appendStep(step);
 		createAST = true;
    	if(previousLocationPath != null){//we need to set haslist=true to the previousLocationPath. this AST is the list of the previous
    		previousLocationPath.setHasList(true);
    	}
    	carryOn=null;
  	}
 	}
  [
  	{
  	//how we go on: if the step is NOT plain xpath, on the current AST we set haslist=true
  	//otherwise, it means we created or merged a locationPath, on which we set haslist=true in case of OXPathPostStepList or following complex predicates/steps 
  	  jjtThis.setHasList(carryOn==null);
  	}
    ( SimpleOXPathStepTail(carryOn) 
  	|
  	XPathPredicate(carryOn)
 	|
 	OXPathNodeTestOp(carryOn)
	|  
  	OXPathPostStepList(){if(carryOn!=null)carryOn.setHasList(true);}
  	)
  	//this is necessary as XPathPredicate or SimpleOXPathStepTail production may be complex and therefore treated as list of the current AST
    { if(carryOn!=null) jjtThis.setHasList(carryOn.hasList());}
  ]
}

Step FullStep() #void:
{Axis axis = ForwardAxis.CHILD;//default unless overwritten
 NodeTest nodetest;}
{  [ ( axis=XPathForwardAxisName()
    | axis=XPathBackwardAxisName()
    | axis=XPathAbbreviatedAxisSpecifier()
    | axis=OXPathAxisSpecifier()
    )
  ]
    ( nodetest=XPathNodeTest() | nodetest=OXPathNodeTest() )  {return new OXPathStep(axis,nodetest);}
}


void OXPathPostStepList() #void:
{}
{
// moved to be inline at each call
// SimpleOXPathStepTail() |
//OXPathNodeTestOp()
//| XPathPredicate()
OXPathOptionalPredicate()
| OXPathExtractionMarker()
}

void OXPathPostStepListOrPredicate() #void:
{}
{
// moved to be inline at each call
// SimpleOXPathStepTail() |
OXPathNodeTestOp(null)
| XPathPredicate(null)
| OXPathOptionalPredicate()
| OXPathExtractionMarker()
}

Axis OXPathAxisSpecifier() #void:
{Axis a;
setPredicateComplex();
}
{
  a=OXPathAxisName() {return a;}
}

Axis XPathForwardAxisName() #void:
{}
{  < ATTRIBUTE > {return ForwardAxis.ATTRIBUTE;}
| < CHILD > {return ForwardAxis.CHILD;}
| < DESCENDANTORSELF > {return ForwardAxis.DESCENDANTORSELF;}
| < DESCENDANT > {return ForwardAxis.DESCENDANT;}
| < FOLLOWINGSIBLING > {return ForwardAxis.FOLLOWINGSIBLING;}
| < FOLLOWING > {return ForwardAxis.FOLLOWING;}
| < NAMESPACE > {return ForwardAxis.NAMESPACE;}
| < SELF > {return ForwardAxis.SELF;}
}

Axis XPathBackwardAxisName() #void:
{}
{
  < ANCESTORORSELF > {return BackwardAxis.ANCESTORORSELF;}
| < ANCESTOR > {return BackwardAxis.ANCESTOR;}
| < PARENT > {return BackwardAxis.PARENT;}
| < PRECEDINGSIBLING > {return BackwardAxis.PRECEDINGSIBLING;}
| < PRECEDING > {return BackwardAxis.PRECEDING;}
}

Axis OXPathAxisName() #void:
{}
{
  < STYLE > {return OXPathAxis.STYLE;}
}


Axis XPathAbbreviatedAxisSpecifier() #void:
{}
{
  < AT > {return AbbreviatedAxis.AT;}
}

NodeTest XPathNodeTest() #void:
{NodeTest nt;
 String parameter = "";}
{
  nt=XPathNameTest() {return nt;}
| < COMMENT > < CLOSE_PARAN > {return XPathNodeTest.COMMENT;}
| < TEXT > < CLOSE_PARAN > {return XPathNodeTest.TEXT;}
| < PROCESSING_INSTRUCTION > [parameter=XPathLiteral(false)] < CLOSE_PARAN > {return (parameter.equals(""))?XPathNodeTest.PROCESSINGINSTRUCTION:new ParameterizedProcessingInstruction(parameter);}
| < NODE > < CLOSE_PARAN > {return XPathNodeTest.NODE;}
}



NodeTest OXPathNodeTest() #void:
{NodeTest nodetest;setPredicateComplex();}
{
  ( < FIELD > {nodetest=OXPathNodeTest.FIELD;} | < ANY_FIELD > {nodetest=OXPathNodeTest.ANYFIELD;} )
  <CLOSE_PARAN >
  {return nodetest;}
}

void OXPathNodeTestOp(MyLocationPath previous) #OXPathNodeTestOp(createAST):
{Selector select;
 Token value;
 boolean createAST = previous==null;
 //setPredicateComplex();
 }
{
  select=OXPathNodeTestOper() value=< NCNAME >
  {
    SelectorPredicate selPred = new SelectorPredicate(select,value.image);
  	jjtThis.setSelectorPredicate(selPred);
  	if(previous!=null){    previous.addSelectorPredicate(selPred);
    cleanScopeForPredicate();//removes from the stack the children nodes not needed 
  	}  }
  [(
    SimpleOXPathStepTail(previous)
  | XPathPredicate(previous)
  | OXPathNodeTestOp(previous)
  | OXPathPostStepList() { if(previous!=null) previous.setHasList(true);}
  )
 { if(createAST) jjtThis.setHasList(true);}
  ]
}

Selector OXPathNodeTestOper() #void:
{}
{
  < PERIOD_OP > {return Selector.CLASS;}
| < HASH > {return Selector.ID;}
}


XPathNameTest XPathNameTest() #void:
{Token tp;
 Token ts;
 NodeTest nt;}
{
  ts=< WILDCARD > {return new XPathNameTest(ts.image,true);}
| tp=< NCNAME >
  [ < COLON >  // COLON only defined in state DEFAULT, while NCNAME switches to IN_PATH_OP
  ( ts=< WILDCARD > {return new XPathNameTest(tp.image,ts.image,true);}
  | ts=< NCNAME > {return new XPathNameTest(tp.image,ts.image,false);} ) ]
  {return new XPathNameTest(tp.image,false);}
}

String XPathLiteral(boolean node) #XPathLiteral(node):
{Token t;}
{
  ( t = < DOUBLE_QUOTE_STRING_PATH > {jjtThis.setValue(t.image); return jjtThis.getValue();} )
  |
  ( t = < SINGLE_QUOTE_STRING_PATH > {jjtThis.setValue(t.image); return jjtThis.getValue();} )
}

void XPathPredicate(MyLocationPath previousLocationPath) #XPathPredicate(createAST):
{
boolean containsComplexPart = false;
boolean hasLeadingPath = false;
if (previousLocationPath != null) {
      hasLeadingPath = openNewPredicateWatcher();
}
boolean createAST = true;
MyLocationPath currentLocationPath = previousLocationPath;
}
{
  < OPEN_BRACKET > XPathExpr() < CLOSE_BRACKET >
  {
	if (hasLeadingPath) {//try to append the predicate to the leading path if doesn't contain not-plain xpath stuff
        containsComplexPart = closePredicateWatcher();
        if (!containsComplexPart) {
          previousLocationPath.addPredicate(jjtree.peekNode());
          createAST = false;
          cleanScopeForPredicate();//removes from the stack the children nodes not needed 
        } else {
          previousLocationPath.setHasList(true);
          currentLocationPath = null; // to break collapsing the following if the current is not collapsed
        }
      }
 }
  
  [
  (  SimpleOXPathStepTail(currentLocationPath)
  | XPathPredicate(currentLocationPath)
  | OXPathNodeTestOp(currentLocationPath)
  | OXPathPostStepList() { if(previousLocationPath!=null) previousLocationPath.setHasList(true);}
  )
  { if(createAST) jjtThis.setHasList(true);  }
  ]
}


void OXPathOptionalPredicate() #XPathPredicate :
{setPredicateComplex();}
{ 
  < OPEN_OPTIONAL > {jjtThis.setIsOptional(true);} XPathExpr() < CLOSE_BRACKET >

  [(  SimpleOXPathStepTail(null)| OXPathPostStepListOrPredicate()) {jjtThis.setHasList(true);}]
}

Action OXPathAction() #void:
{Action a;}
{
  (    a=OXPathURLAction() | a=OXPathUserAction()
  )
  {return a;}
}

Action OXPathURLAction() #void:
{Action a;
 String s;
 long l;}
{
  < BEGIN_URL_IN_PATH > s=URLName() < END_URL_IN_PATH >
  {a= new URLAction(s);}
  [OXPathActionPred(a)]
  < SLASH > < CLOSE_CURLY >
| < DOC_BEGIN > s=XPathLiteral(false)
  {a= new URLAction(s);}
  [< COMMA > OXPathActionPred(a)]
  < CLOSE_PARAN >
  {return a;}
}


Action OXPathUserAction() #void:
{Action a;
 long l;}
{
  < BEGIN_USER_ACTION >
  ( a=GroundedOXPathActionPosition()
  | a=GroundedOXPathActionExplicit()
  | a=OXPathActionKeyword()
  | a=OXPathActionVariable())
  [ OXPathActionPred(a) ]
  [ OXPathAbsoluteActionSignal() {a.setIsAbsoluteAction(true);} ]
  < CLOSE_CURLY >
  {return a;}
}

void OXPathActionPred(Action a) #void:
{}
{
  < OPEN_BRACKET > OXPathActionPredList(a) (< COMMA > OXPathActionPredList(a))*< CLOSE_BRACKET >
}

void OXPathActionPredList(Action a) #void:
{long wait;}
{
  (     wait=OXPathActionWaitPred(){a.setWait(wait);}
   |
    < NOBACK >    {a.isBackActionNeeded(false);}
)
}


long OXPathActionWaitPred() #void:
{Token wait;}
{
  < WAIT > wait=< DIGITS >
  {return Long.parseLong(wait.image);}
}

void OXPathAbsoluteActionSignal() #void:
{}
{
  < SLASH >
}

Action GroundedOXPathActionPosition() #void:
{Token t;}
{
  t=< DIGITS > {return new PositionAction(Integer.parseInt(t.image));}
}

Action GroundedOXPathActionExplicit() #void:
{String s;}
{
  s=XPathLiteral(false) {return new ExplicitAction(s);}
}

Action OXPathActionKeyword() #void:
{Token t;}
{
  t=< FOCUS > {return new KeywordAction(ActionKeywords.FOCUS);}
| t=< CLICK > {return new KeywordAction(ActionKeywords.CLICK);}
| t=< CLICKWITHCHANGE > {return new KeywordAction(ActionKeywords.CLICKWITHCHANGE);}
| t=< NEXTCLICK > {return new KeywordAction(ActionKeywords.NEXTCLICK);}
| t=< PRESSENTER > {return new KeywordAction(ActionKeywords.PRESSENTER);}
| t=< ENTERFRAME > {return new KeywordAction(ActionKeywords.ENTERFRAME);}
| t=< MOVETOFRAME > {return new KeywordAction(ActionKeywords.MOVETOFRAME);}
| t=< MOVETOHREF > {return new KeywordAction(ActionKeywords.MOVETOHREF);}
| t=< DBLCLICK > {return new KeywordAction(ActionKeywords.DBLCLICK);}
| t=< MOUSEDOWN > {return new KeywordAction(ActionKeywords.MOUSEDOWN);}
| t=< MOUSEENTER > {return new KeywordAction(ActionKeywords.MOUSEENTER);}
| t=< MOUSEMOVE > {return new KeywordAction(ActionKeywords.MOUSEMOVE);}
| t=< MOUSEOVER > {return new KeywordAction(ActionKeywords.MOUSEOVER);}
| t=< MOUSEOUT > {return new KeywordAction(ActionKeywords.MOUSEOUT);}
| t=< MOUSEUP > {return new KeywordAction(ActionKeywords.MOUSEUP);}
| t=< WHEEL > {return new KeywordAction(ActionKeywords.WHEEL);}
| t=< SUBMIT > {return new KeywordAction(ActionKeywords.SUBMIT);}
| t=< CHECK > {return new KeywordAction(ActionKeywords.CHECK);}
| t=< UNCHECK > {return new KeywordAction(ActionKeywords.UNCHECK);}
}

Action OXPathActionVariable() #void:
{Token t;}
{
  t=< VARIABLE > {return new VariableAction(t.image);}
}

void OXPathExtractionMarker() :
{String s; OXPathExtractionMarker marker;
setPredicateComplex();
}
{
  < BEGIN_EXTRACT_MARK >
  s=OXPathExtractionName() { marker=new OXPathExtractionMarker(s,false); }
	//we allow rdf types for both record extraction and attribute extractions.
  [ < OPEN_PARAN > s=OXPathExtractionName() { marker.addRdfType(s); }
    ( < COMMA > s=OXPathExtractionName() { marker.addRdfType(s);} )*
    < CLOSE_PARAN > [< EQUALS > OXPathExtractionValue() { marker.setAttribute(true); }]
  | < EQUALS > OXPathExtractionValue() { marker.setAttribute(true); }
  ]

  (< END_EXTRACT_MARK > | < GREATER >) //We overload ">" so we don't have to overly generalize the greater operator
  {jjtThis.setExtractionMarker(marker);}

  [(  SimpleOXPathStepTail(null)| OXPathPostStepListOrPredicate()) {jjtThis.setHasList(true);}]
}

String OXPathExtractionName() #void:
{Token t; String s;}
{
// PRE RDF Code:
//  t=< NCNAME > {return t.image;}

// We allow now colons in the name for namespace separation.
  t=< NCNAME > { s=t.image; }
  [ < COLON > t=< NCNAME > { s=s+":"+t.image; } ]
  { return s; }
}

void OXPathExtractionValue() #void:
{}
{
  XPathPrimaryExpr()
}


void XPathExpr() #void:
{}
{
  XPathOrExpr()
}

void XPathOrExpr() #BinaryOpExpr(>1):
{}
{
  XPathAndExpr() [ < OR > {jjtThis.setBinaryOperator(HigherLevelOp.OR);} XPathOrExpr() ]
}

void XPathAndExpr() #BinaryOpExpr(>1):
{}
{
  XPathEqualityExpr() [ < AND > {jjtThis.setBinaryOperator(HigherLevelOp.AND);} XPathAndExpr() ]
}

void XPathEqualityExpr() #BinaryOpExpr(>1):
{EqualityExprOp op;}
{
  XPathRelationalExpr()
  [  op=XPathEqualityExprOp() {jjtThis.setBinaryOperator(op);}
     XPathEqualityExpr() ]
}

EqualityExprOp XPathEqualityExprOp() #void:
{}
{
  < EQUALS > {return EqualityExprOp.EQUALS;}
| < NOTEQUAL > {return EqualityExprOp.NOTEQUAL;}
| < WORD_TEST >  {return EqualityExprOp.WORDTEST;}
| < CONTAINS >  {return EqualityExprOp.CONTAINS;}
}


void XPathRelationalExpr() #BinaryOpExpr(>1):
{RelationalExprOp op;}
{//here, right-associative, rather than left-associative in XPath standard
  XPathAdditiveExpr()
  [ op=XPathRelationalExprOp() {jjtThis.setBinaryOperator(op);}
    XPathRelationalExpr() ]
}

RelationalExprOp XPathRelationalExprOp() #void:
{}
{
  (
  < GREATER > {return RelationalExprOp.GREATER;}
| < LESS > {return RelationalExprOp.LESS;}
| < GREATERTE > {return RelationalExprOp.GREATERTE;}
| < LESSTE > {return RelationalExprOp.LESSTE;}
)
}

void XPathAdditiveExpr() #BinaryOpExpr(>1):
{AdditiveExprOp op;}
{
  XPathMultiplicativeExpr()
  [ op=AdditiveExprOp() {jjtThis.setBinaryOperator(op);}
     XPathAdditiveExpr() ]
}

AdditiveExprOp AdditiveExprOp() #void:
{}
{
  < PLUS > {return AdditiveExprOp.PLUS;}
| < MINUS > {return AdditiveExprOp.MINUS;}
}

void XPathMultiplicativeExpr() #BinaryOpExpr(>1):
{MultiplicativeExprOp op;}
{
  XPathUnaryExpr()
  [ op=MultiplicativeExprOp() {jjtThis.setBinaryOperator(op);}
    XPathMultiplicativeExpr() ]
}

MultiplicativeExprOp MultiplicativeExprOp() #void:
{}
{
  < MULTIPLY > {return MultiplicativeExprOp.MULTIPLY;}
| < DIV > {return MultiplicativeExprOp.DIV;}
| < MOD > {return MultiplicativeExprOp.MOD;}
}

void XPathUnaryExpr() #XPathUnaryExpr(hasOp):
{boolean hasOp = false;}
{
  ( XPathUnaryExprOp() {jjtThis.incrementOperatorNumber(); hasOp=true;} )* XPathUnionExpr()
}

void XPathUnaryExprOp() #void:
{}
{
  < NEGATIVE >
}

void XPathPrimaryExpr() #XPathPrimaryExpr(parans):
{boolean parans = false;}
{
  < OPEN_PARAN > {parans=true;} XPathExpr() < CLOSE_PARAN >
| XPathLiteral(true)
| XPathNumber()
| XPathFunctionCall()
}

double XPathNumber() :
{Token t;}
{
  t=< NUMBER > {jjtThis.setValue(Double.parseDouble(t.image)); return jjtThis.getValue();}
| t=< DIGITS > {jjtThis.setValue(Double.parseDouble(t.image)); return jjtThis.getValue();}
}

void XPathFunctionCall() :
{XPathFunction function;}
{
	(    	function=XPathFunctionCallName()
  		|
    	function=XPathUserFunctionCallName()
	)
    {jjtThis.setFunction(function);}
  [ XPathArgument() {jjtThis.addParameter();} ( < COMMA > XPathArgument() {jjtThis.addParameter();} )* ]
  < CLOSE_PARAN >
}

XPathFunction XPathFunctionCallName() #void:
{Token t;}
{
  < POSITION > {return XPathFunctions.POSITION;}
| < LAST > {return XPathFunctions.LAST;}
| < COUNT > {return XPathFunctions.COUNT;}
| < ID > {return XPathFunctions.ID;}
| < LOCALNAME > {return XPathFunctions.LOCALNAME;}
| < NAMESPACEURI > {return XPathFunctions.NAMESPACEURI;}
| < NAME > {return XPathFunctions.NAME;}
| < STRING > {return XPathFunctions.STRING;}
| < CONCAT > {return XPathFunctions.CONCAT;}
| < STARTSWITH > {return XPathFunctions.STARTSWITH;}
| < CONTAINSFUNC > {return XPathFunctions.CONTAINS;}
| < SUBSTRINGBEFORE > {return XPathFunctions.SUBSTRINGBEFORE;}
| < SUBSTRINGAFTER > {return XPathFunctions.SUBSTRINGAFTER;}
| < SUBSTRING > {return XPathFunctions.SUBSTRING;}
| < SUBSTRINGLENGTH >  {return XPathFunctions.SUBSTRINGLENGTH;}
| < NORMALIZESPACE > {return XPathFunctions.NORMALIZESPACE;}
| < TRANSLATE > {return XPathFunctions.TRANSLATE;}
| < BOOLEAN > {return XPathFunctions.BOOLEAN;}
| < NOT > {return XPathFunctions.NOT;}
| < TRUE > {return XPathFunctions.TRUE;}
| < FALSE > {return XPathFunctions.FALSE;}
| < LANG > {return XPathFunctions.LANG;}
| < NUMBERFUNC > {return XPathFunctions.NUMBER;}
| < SUM > {return XPathFunctions.SUM;}
| < FLOOR > {return XPathFunctions.FLOOR;}
| < CEILING > {return XPathFunctions.CEILING;}
| < ROUND > {return XPathFunctions.ROUND;}

}


XPathFunction XPathUserFunctionCallName() #void:
{Token t; setPredicateComplex();}
{
 < MINUS_FUNC > {return XPathFunctions.MINUS_FUNC;}
| < PLUS_FUNC > {return XPathFunctions.PLUS_FUNC;}
| < SUBSTRINGBEFOREREVERSE > {return XPathFunctions.SUBSTRINGBEFOREREVERSE;}
| < SUBSTRINGAFTERREVERSE > {return XPathFunctions.SUBSTRINGAFTERREVERSE;}
| < SUBSTRINGREVERSE > {return XPathFunctions.SUBSTRINGREVERSE;}
| < REPLACE > {return XPathFunctions.REPLACE;}
| < STRINGJOIN > {return XPathFunctions.STRINGJOIN;}
//meta function added when necessary
| < CURRENTURL > {return XPathFunctions.CURRENTURL;}
| < PAGECONTENT > {return XPathFunctions.PAGECONTENT;}
| < SCREENSHOT > {return XPathFunctions.SCREENSHOT;}
| < SAVEPAGE > {return XPathFunctions.SAVEPAGE;}
| < NOW > {return XPathFunctions.NOW;}
| < URIFY > {return XPathFunctions.URIFY;}
| < JAROWRINKLER > {return XPathFunctions.JAROWRINKLER;}
| < QUALIFYURL > {return XPathFunctions.QUALIFYURL;}
| < DOMPROPERTY > {return XPathFunctions.DOMPROPERTY;}
| < SELECTTEXT > {return XPathFunctions.SELECTTEXT;}
| < INNERHTML> {return XPathFunctions.INNERHTML;}
| < OUTERHTML> {return XPathFunctions.OUTERHTML;}
| < TOXML> {return XPathFunctions.TOXML;}
| < ISVISIBLE > {return XPathFunctions.ISVISIBLE;}
| < ISINVISIBLE > {return XPathFunctions.ISINVISIBLE;}


}

void XPathArgument() #void:
{}
{
  XPathExpr()
}

void XPathUnionExpr() #BinaryOpExpr(>1):
{}
{
  XPathPathExpr() [ < UNION >  {jjtThis.setBinaryOperator(HigherLevelOp.UNION);} XPathUnionExpr() ]
}

// * The WARNING generated by the ambiguity in this rule is purposeful; the default (first rule condition satisfied) is what we always want.
// * This is because we restrict Kleene-Stars that begin with path expressions to start with / or // (in this way, no relative expressions can start with Kleene stars).
// * This restriction is necessary so as to save arbitrary lookahead as an entire unbounded relative OXPath expression must be parsed to determine if an operator and new expression occur afterwards.
// * This restriction results in no loss of expressivity.  Simply use ./(Kleene-star-expr)* in order to preserve context.
// * We treat the additional OXPath "step" feature - user actions - similiarly.
// * The LOOKAHEAD(1) is to simply suppress the warning; lets JavaCC know that the ambiguity was a deliberate choice.
void XPathPathExpr() #XPathPathExpr(>1):
{}
{//incorporates the filter expression (first line conditional path of the production rule)
 LOOKAHEAD(1)
   XPathPrimaryExpr() [ (  SimpleOXPathStepTail(null)| OXPathPostStepListOrPredicate()) {jjtThis.setHasSimpleList(true);} ] [ ComplexOXPathStepPath() {jjtThis.setHasComplexList(true);}]
|  OXPathPathSegment()
}


//here, we restrict the Complex steps similiarly so that //ComplexOXPathStepPath isn't possible.
//as with the restriction of the relative OXPath location path beginning with a complex step, this restriction
//makes a cleaner semantics, a much more efficient parser (we remain at LL(1)), and no loss of expressivity (as
//this can be simulated with //*/ComplexOXPathStepPath
void AbbreviatedAbsoluteOXPathLocationPath() #RelativeOXPathLocationPath:
{}
{
  SimpleOXPathDOSStepPath(null) {jjtThis.setHasSimplePath(true);}
  [ComplexOXPathStepPath() {jjtThis.setHasComplexPath(true);}]
}

Step AbbreviatedStep() #void:
{Step s;}
{
(    s=AbbreviatedSelfStep()
  | s=AbbreviatedParentStep()
)
{return s;}
}

Step AbbreviatedSelfStep() #void:
{}
{  < PERIOD > {return AbbreviatedStep.SELF;}
}

Step AbbreviatedParentStep() #void:
{}
{  < PARENT_SHORT > {return AbbreviatedStep.PARENT;}
}