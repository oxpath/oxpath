/* Generated By:JJTree&JavaCC: Do not edit this line. OXPathParser.java */
package uk.ac.ox.cs.diadem.oxpath.parse;
import java.io.FileReader;
import java.io.Reader;
import java.io.StringReader;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;

import org.apache.commons.lang3.mutable.MutableBoolean;

import uk.ac.ox.cs.diadem.oxpath.core.ActionKeywords;
import uk.ac.ox.cs.diadem.oxpath.core.OXPathException;
import uk.ac.ox.cs.diadem.oxpath.model.language.AbbreviatedAxis;
import uk.ac.ox.cs.diadem.oxpath.model.language.AbbreviatedStep;
import uk.ac.ox.cs.diadem.oxpath.model.language.Action;
import uk.ac.ox.cs.diadem.oxpath.model.language.Axis;
import uk.ac.ox.cs.diadem.oxpath.model.language.BackwardAxis;
import uk.ac.ox.cs.diadem.oxpath.model.language.ExplicitAction;
import uk.ac.ox.cs.diadem.oxpath.model.language.ForwardAxis;
import uk.ac.ox.cs.diadem.oxpath.model.language.KeywordAction;
import uk.ac.ox.cs.diadem.oxpath.model.language.MyLocationPath;
import uk.ac.ox.cs.diadem.oxpath.model.language.NodeTest;
import uk.ac.ox.cs.diadem.oxpath.model.language.OXPathAxis;
import uk.ac.ox.cs.diadem.oxpath.model.language.OXPathExtractionMarker;
import uk.ac.ox.cs.diadem.oxpath.model.language.OXPathNodeTest;
import uk.ac.ox.cs.diadem.oxpath.model.language.OXPathStep;
import uk.ac.ox.cs.diadem.oxpath.model.language.ParameterizedProcessingInstruction;
import uk.ac.ox.cs.diadem.oxpath.model.language.PositionAction;
import uk.ac.ox.cs.diadem.oxpath.model.language.Selector;
import uk.ac.ox.cs.diadem.oxpath.model.language.SelectorPredicate;
import uk.ac.ox.cs.diadem.oxpath.model.language.Step;
import uk.ac.ox.cs.diadem.oxpath.model.language.URLAction;
import uk.ac.ox.cs.diadem.oxpath.model.language.VariableAction;
import uk.ac.ox.cs.diadem.oxpath.model.language.XPathNameTest;
import uk.ac.ox.cs.diadem.oxpath.model.language.XPathNodeTest;
import uk.ac.ox.cs.diadem.oxpath.model.language.functions.XPathFunction;
import uk.ac.ox.cs.diadem.oxpath.model.language.functions.XPathFunctions;
import uk.ac.ox.cs.diadem.oxpath.model.language.operators.AdditiveExprOp;
import uk.ac.ox.cs.diadem.oxpath.model.language.operators.EqualityExprOp;
import uk.ac.ox.cs.diadem.oxpath.model.language.operators.HigherLevelOp;
import uk.ac.ox.cs.diadem.oxpath.model.language.operators.MultiplicativeExprOp;
import uk.ac.ox.cs.diadem.oxpath.model.language.operators.RelationalExprOp;
import uk.ac.ox.cs.diadem.oxpath.parse.ast.ASTBinaryOpExpr;
import uk.ac.ox.cs.diadem.oxpath.parse.ast.ASTExpression;
import uk.ac.ox.cs.diadem.oxpath.parse.ast.ASTOXPathActionPath;
import uk.ac.ox.cs.diadem.oxpath.parse.ast.ASTOXPathExtractionMarker;
import uk.ac.ox.cs.diadem.oxpath.parse.ast.ASTOXPathKleeneStarPath;
import uk.ac.ox.cs.diadem.oxpath.parse.ast.ASTOXPathNodeTestOp;
import uk.ac.ox.cs.diadem.oxpath.parse.ast.ASTRelativeOXPathLocationPath;
import uk.ac.ox.cs.diadem.oxpath.parse.ast.ASTSimpleOXPathStepPath;
import uk.ac.ox.cs.diadem.oxpath.parse.ast.ASTXPathFunctionCall;
import uk.ac.ox.cs.diadem.oxpath.parse.ast.ASTXPathLiteral;
import uk.ac.ox.cs.diadem.oxpath.parse.ast.ASTXPathNumber;
import uk.ac.ox.cs.diadem.oxpath.parse.ast.ASTXPathPathExpr;
import uk.ac.ox.cs.diadem.oxpath.parse.ast.ASTXPathPredicate;
import uk.ac.ox.cs.diadem.oxpath.parse.ast.ASTXPathPrimaryExpr;
import uk.ac.ox.cs.diadem.oxpath.parse.ast.ASTXPathUnaryExpr;
import uk.ac.ox.cs.diadem.oxpath.parse.ast.JJTOXPathParserState;
import uk.ac.ox.cs.diadem.oxpath.parse.ast.Node;
import uk.ac.ox.cs.diadem.oxpath.parse.ast.OXPathParserTreeConstants;

/**
 *OXPath parser autogenerated by javacc
 * @author Giovanni Grasso <gio@oxpath.org>
 */
public class OXPathParser/*@bgen(jjtree)*/implements OXPathParserTreeConstants, OXPathParserConstants {/*@bgen(jjtree)*/
  protected JJTOXPathParserState jjtree = new JJTOXPathParserState();Deque<MutableBoolean> predicateStack = new ArrayDeque<MutableBoolean>();
  public OXPathParser()
  {

  }

  public static void main(String args [])
  {
    try
    {
      FileReader reader = new FileReader(args[0]);
      OXPathParser oxpathparser = new OXPathParser(reader);
      Node n = oxpathparser.Expression();
    }
    catch (Exception e)
    {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }

  boolean openNewPredicateWatcher() {
   // if (predicateStack.isEmpty()) {
      predicateStack.addFirst(new MutableBoolean());
      return true;
    //}
    //return false;
  }

  boolean closePredicateWatcher() {
    return predicateStack.removeFirst().toBoolean();
  }

void cleanScopeForPredicate()
{
  int toRemove = jjtree.nodeArity();
          while (toRemove-- > 0) {
            jjtree.popNode();
          }
}
  void setPredicateComplex() {
    // MutableBoolean first = predicateStack.peekFirst();
    // if(first != null)
    // first.setValue(true);

    for (final MutableBoolean mutableBoolean : predicateStack) {
      mutableBoolean.setValue(true);
    }
  }

  /**
   * Returns JJTree of script
   */
  public static Node getJJTree(String inputfile) throws OXPathException {
    try {
      FileReader reader = new FileReader(inputfile);
      OXPathParser oxpathparser = new OXPathParser(reader);
      return oxpathparser.Expression();
    } catch (Exception e) {
      throw new OXPathException("Parser exception!",e);
    }
  }

  public static Node getJJTreeFromString(String in) throws OXPathException
  {
    try
    {
      return new OXPathParser(new StringReader(in)).Expression();
    } catch (Exception e)
    {
      throw new OXPathException("Parser Exception!",e);
    }
  }

 public static Node getJJTreeFromReader(Reader in) throws OXPathException
  {
    try
    {
      return new OXPathParser(in).Expression();
    } catch (Exception e)
    {
      throw new OXPathException("Parser Exception!",e);
    }
  }

  public static Node safeGetChild(Node parent, int index) throws OXPathException {
    if (isSafeChild(parent,index))
    {
      return parent.jjtGetChild(index);
    }
    else throw new OXPathException("Not an OXPath AST node!");
  }

  public static boolean isSafeChild(Node parent, int index) {
    if (parent.jjtGetChild(index) instanceof Node)
    {
      return true;
    }
    else
    {
      return false;
    }
  }

  public static boolean hasChildByName(Node parent, String name)
  {
    for (int i = 0; i<parent.jjtGetNumChildren(); i++)
    {
      if (parent.jjtGetChild(i).toString().contains(name))
      {
        return true;
      }
    }
    return false;
  }

  public static boolean hasDescendantOrSelfByName(Node parent, String name) throws OXPathException
  {
    if (parent.toString().contains(name)) return true;
    else
    {
      for (int i = 0; i<parent.jjtGetNumChildren(); i++)
      {
        if (hasDescendantOrSelfByName(parent.jjtGetChild(i),name)) {
          return true;
        }
      }
    }
    return false;
  }

  public static boolean hasActionOnMainPath(Node node)
  {
    if (node.toString().contains("ASTOXPathActionPath")) return true;
    else
    {
      for (int i = 0; i < node.jjtGetNumChildren(); i++)
      {
        Node child = node.jjtGetChild(i);
        if (!child.toString().contains("ASTSimpleOXPathStepPath") && hasActionOnMainPath(child)) return true;
      }
      return false;
    }
  }

  public static Node getChildByName(Node parent, String name) throws OXPathException
  {
    for (int i = 0; i<parent.jjtGetNumChildren(); i++)
    {
      if (parent.jjtGetChild(i).toString().contains(name))
      {
        return safeGetChild(parent,i);
      }
    }
    throw new OXPathException("Child not found!");
  }

  public static int test(String tester)
  {
    System.out.println(tester);
    return 1;
  }

  public static boolean isDescendant(Node a, Node d)
  {
    if (a.equals(d)) return true;
    Node temp = d.jjtGetParent();
    while (!(temp==null))
    {
      if (a.equals(temp)) return true;
      temp = temp.jjtGetParent();
    }
    return false;
  }

//Apparently, we can't get rid of this - the AST needs a fixed root node for JavaCC
  final public Node Expression() throws ParseException {
 /*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      XPathExpr();
      jj_consume_token(0);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String Letter() throws ParseException {
 Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UPPER_ALPHA:
      t = jj_consume_token(UPPER_ALPHA);
                        {if (true) return t.image;}
      break;
    case LOWER_ALPHA:
      t = jj_consume_token(LOWER_ALPHA);
                          {if (true) return t.image;}
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String URLName() throws ParseException {
 StringBuilder sb = new StringBuilder();
 String sp;
 String hp;
 Token t1;
 String up;
 Token t2;
 String us;
    //adapted from w3c BNF grammar for BNF located @ http://www.w3.org/Addressing/URL/5_BNF.html#z18
      sp = SupportedProtocols();
    hp = HostPort();
                                             sb.append(sp); sb.append(hp);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SLASH_URL:
      t1 = jj_consume_token(SLASH_URL);
      up = URLPath();
                                        sb.append(t1.image); sb.append(up);
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUESTION_URL:
      t2 = jj_consume_token(QUESTION_URL);
      us = URLSearch();
                                            sb.append(t2.image); sb.append(us);
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
   {if (true) return sb.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String SupportedProtocols() throws ParseException {
 Token t;
    //current supported protocols of http and https
      t = jj_consume_token(PROTOCOL);
   {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public String HostPort() throws ParseException {
 StringBuilder sb = new StringBuilder();
 String h;
 Token t;
 int p;
    h = Host();
              sb.append(h);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      t = jj_consume_token(COLON);
      p = Port();
                                                         sb.append(t.image); sb.append(p);
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
   {if (true) return sb.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String Host() throws ParseException {
 String subtree;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOWER_ALPHA:
    case UPPER_ALPHA:
      subtree = HostName();
                         {if (true) return subtree;}
      break;
    case DIGIT:
      subtree = HostNumber();
                               {if (true) return subtree;}
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String HostName() throws ParseException {
 String subtree;
    subtree = URLIAlpha();
                         {if (true) return subtree;}
    throw new Error("Missing return statement in function");
  }

  final public String URLIAlpha() throws ParseException {
 StringBuilder st = new StringBuilder();
 String l;
 String u;
    l = Letter();
              st.append(l);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case APOSTROPHE_URL:
    case QUOTE_URL:
    case MINUS_URL:
    case UNDERSCORE_URL:
    case PERIOD_URL:
    case AMPERSAND_URL:
    case EQUALS_URL:
    case DOLLAR_URL:
    case PERCENT_URL:
    case AT_URL:
    case PLUS_URL:
    case EXCLAIMATION_URL:
    case STAR_URL:
    case OPEN_PARAN_URL:
    case CLOSE_PARAN_URL:
    case COMMA_URL:
    case LOWER_ALPHA:
    case UPPER_ALPHA:
    case DIGIT:
      u = URLXAlphas();
                                               st.append(u);
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
   {if (true) return st.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String URLXAlphas() throws ParseException {
 StringBuilder sb = new StringBuilder();
 String u;
 String us;
    u = URLXAlpha();
                  sb.append(u);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case APOSTROPHE_URL:
    case QUOTE_URL:
    case MINUS_URL:
    case UNDERSCORE_URL:
    case PERIOD_URL:
    case AMPERSAND_URL:
    case EQUALS_URL:
    case DOLLAR_URL:
    case PERCENT_URL:
    case AT_URL:
    case PLUS_URL:
    case EXCLAIMATION_URL:
    case STAR_URL:
    case OPEN_PARAN_URL:
    case CLOSE_PARAN_URL:
    case COMMA_URL:
    case LOWER_ALPHA:
    case UPPER_ALPHA:
    case DIGIT:
      us = URLXAlphas();
                                                      sb.append(us);
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
  {if (true) return sb.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String URLXAlpha() throws ParseException {
 String s;
 Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOWER_ALPHA:
    case UPPER_ALPHA:
      s = Letter();
                      {if (true) return s;}
      break;
    case DIGIT:
      t = jj_consume_token(DIGIT);
                       {if (true) return t.image;}
      break;
    case MINUS_URL:
    case UNDERSCORE_URL:
    case PERIOD_URL:
    case AMPERSAND_URL:
    case EQUALS_URL:
    case DOLLAR_URL:
    case AT_URL:
    case PLUS_URL:
      s = URLSafe();
                       {if (true) return s;}
      break;
    case APOSTROPHE_URL:
    case QUOTE_URL:
    case EXCLAIMATION_URL:
    case STAR_URL:
    case OPEN_PARAN_URL:
    case CLOSE_PARAN_URL:
    case COMMA_URL:
      s = URLExtra();
                        {if (true) return s;}
      break;
    case PERCENT_URL:
      s = URLEscape();
                         {if (true) return s;}
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String URLSafe() throws ParseException {
 Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOLLAR_URL:
      t = jj_consume_token(DOLLAR_URL);
                    {if (true) return t.image;}
      break;
    case MINUS_URL:
      t = jj_consume_token(MINUS_URL);
                   {if (true) return t.image;}
      break;
    case UNDERSCORE_URL:
      t = jj_consume_token(UNDERSCORE_URL);
                        {if (true) return t.image;}
      break;
    case AT_URL:
      t = jj_consume_token(AT_URL);
                {if (true) return t.image;}
      break;
    case PERIOD_URL:
      t = jj_consume_token(PERIOD_URL);
                    {if (true) return t.image;}
      break;
    case AMPERSAND_URL:
      t = jj_consume_token(AMPERSAND_URL);
                       {if (true) return t.image;}
      break;
    case PLUS_URL:
      t = jj_consume_token(PLUS_URL);
                  {if (true) return t.image;}
      break;
    case EQUALS_URL:
      t = jj_consume_token(EQUALS_URL);
                    {if (true) return t.image;}
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String URLExtra() throws ParseException {
 Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXCLAIMATION_URL:
      t = jj_consume_token(EXCLAIMATION_URL);
                          {if (true) return t.image;}
      break;
    case STAR_URL:
      t = jj_consume_token(STAR_URL);
                  {if (true) return t.image;}
      break;
    case QUOTE_URL:
      t = jj_consume_token(QUOTE_URL);
                   {if (true) return t.image;}
      break;
    case APOSTROPHE_URL:
      t = jj_consume_token(APOSTROPHE_URL);
                        {if (true) return t.image;}
      break;
    case OPEN_PARAN_URL:
      t = jj_consume_token(OPEN_PARAN_URL);
                        {if (true) return t.image;}
      break;
    case CLOSE_PARAN_URL:
      t = jj_consume_token(CLOSE_PARAN_URL);
                         {if (true) return t.image;}
      break;
    case COMMA_URL:
      t = jj_consume_token(COMMA_URL);
                   {if (true) return t.image;}
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String URLEscape() throws ParseException {
 Token t;
    t = jj_consume_token(PERCENT_URL);
                     {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public String HostNumber() throws ParseException {
 int s1;
 Token t1;
 int s2;
 Token t2;
 int s3;
 Token t3;
 int s4;
    s1 = Digits();
    t1 = jj_consume_token(PERIOD_URL);
    s2 = Digits();
    t2 = jj_consume_token(PERIOD_URL);
    s3 = Digits();
    t3 = jj_consume_token(PERIOD_URL);
    s4 = Digits();
   StringBuilder sb = new StringBuilder();
   sb.append(s1);
   sb.append(t1);
   sb.append(s2);
   sb.append(t2);
   sb.append(s3);
   sb.append(t3);
   sb.append(s4);
   {if (true) return sb.toString();}
    throw new Error("Missing return statement in function");
  }

  final public int Digits() throws ParseException {
 Token t;
 StringBuilder sb = new StringBuilder();
    label_1:
    while (true) {
      t = jj_consume_token(DIGIT);
                 sb.append(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGIT:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_1;
      }
    }
   {if (true) return Integer.parseInt(sb.toString());}
    throw new Error("Missing return statement in function");
  }

  final public int Port() throws ParseException {
 int s;
    s = Digits();
              {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public String URLPath() throws ParseException {
 StringBuilder sb = new StringBuilder();
 String s1;
 Token t;
 String s2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case APOSTROPHE_URL:
    case QUOTE_URL:
    case MINUS_URL:
    case UNDERSCORE_URL:
    case PERIOD_URL:
    case AMPERSAND_URL:
    case EQUALS_URL:
    case DOLLAR_URL:
    case PERCENT_URL:
    case AT_URL:
    case PLUS_URL:
    case EXCLAIMATION_URL:
    case STAR_URL:
    case OPEN_PARAN_URL:
    case CLOSE_PARAN_URL:
    case COMMA_URL:
    case LOWER_ALPHA:
    case UPPER_ALPHA:
    case DIGIT:
      s1 = URLSegment();
                    sb.append(s1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SLASH_URL:
        t = jj_consume_token(SLASH_URL);
        s2 = URLPath();
                                                                    sb.append(t.image); sb.append(s2);
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
   {if (true) return sb.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String URLSegment() throws ParseException {
 String s;
    s = URLXAlphas();
                  {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public String URLSearch() throws ParseException {
 String s;
    s = URLXAlphas();
                  {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public void OXPathPathSegment() throws ParseException {
 /*@bgen(jjtree) RelativeOXPathLocationPath */
  ASTRelativeOXPathLocationPath jjtn000 = new ASTRelativeOXPathLocationPath(JJTRELATIVEOXPATHLOCATIONPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOC_BEGIN:
      case BEGIN_URL_IN_PATH:
      case BEGIN_USER_ACTION:
      case BEGIN_KLEENE_STAR:
        ComplexOXPathStepPath();
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                           jjtn000.setHasComplexPath(true);
        break;
      case STYLE:
      case ATTRIBUTE:
      case CHILD:
      case DESCENDANTORSELF:
      case DESCENDANT:
      case FOLLOWINGSIBLING:
      case FOLLOWING:
      case NAMESPACE:
      case SELF:
      case ANCESTORORSELF:
      case ANCESTOR:
      case PARENT:
      case PRECEDINGSIBLING:
      case PRECEDING:
      case COMMENT:
      case TEXT:
      case PROCESSING_INSTRUCTION:
      case NODE:
      case FIELD:
      case ANY_FIELD:
      case PERIOD:
      case PARENT_SHORT:
      case AT:
      case WILDCARD:
      case NCNAME:
        SimpleOXPathStepPath(null);
                              jjtn000.setHasSimplePath(true);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOC_BEGIN:
        case BEGIN_URL_IN_PATH:
        case BEGIN_USER_ACTION:
        case BEGIN_KLEENE_STAR:
          ComplexOXPathStepPath();
                                                                                          jjtn000.setHasComplexPath(true);
          break;
        default:
          jj_la1[13] = jj_gen;
          ;
        }
        break;
      case DESCENDENT_OR_SELF_SHORT:
      case SLASH:
        SimpleOXPathStepTail(null);
                              jjtn000.setIsAbsolutePath(true); jjtn000.setHasSimplePath(true);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOC_BEGIN:
        case BEGIN_URL_IN_PATH:
        case BEGIN_USER_ACTION:
        case BEGIN_KLEENE_STAR:
          ComplexOXPathStepPath();
                                                                                                                          jjtn000.setHasComplexPath(true);
          break;
        default:
          jj_la1[14] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void RelativeOXPathLocationPath() throws ParseException {
 /*@bgen(jjtree) RelativeOXPathLocationPath */
  ASTRelativeOXPathLocationPath jjtn000 = new ASTRelativeOXPathLocationPath(JJTRELATIVEOXPATHLOCATIONPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOC_BEGIN:
      case BEGIN_URL_IN_PATH:
      case BEGIN_USER_ACTION:
      case BEGIN_KLEENE_STAR:
        ComplexOXPathStepPath();
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                           jjtn000.setHasComplexPath(true);
        break;
      case STYLE:
      case ATTRIBUTE:
      case CHILD:
      case DESCENDANTORSELF:
      case DESCENDANT:
      case FOLLOWINGSIBLING:
      case FOLLOWING:
      case NAMESPACE:
      case SELF:
      case ANCESTORORSELF:
      case ANCESTOR:
      case PARENT:
      case PRECEDINGSIBLING:
      case PRECEDING:
      case COMMENT:
      case TEXT:
      case PROCESSING_INSTRUCTION:
      case NODE:
      case FIELD:
      case ANY_FIELD:
      case PERIOD:
      case PARENT_SHORT:
      case AT:
      case WILDCARD:
      case NCNAME:
        SimpleOXPathStepPath(null);
                              jjtn000.setHasSimplePath(true);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOC_BEGIN:
        case BEGIN_URL_IN_PATH:
        case BEGIN_USER_ACTION:
        case BEGIN_KLEENE_STAR:
          ComplexOXPathStepPath();
                                                                                          jjtn000.setHasComplexPath(true);
          break;
        default:
          jj_la1[16] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void SimpleOXPathStepTail(MyLocationPath previous) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SLASH:
      jj_consume_token(SLASH);
      SimpleOXPathStepPath(previous);
      break;
    case DESCENDENT_OR_SELF_SHORT:
      SimpleOXPathDOSStepPath(previous);

      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void SimpleOXPathDOSStepPath(MyLocationPath previous) throws ParseException {
 /*@bgen(jjtree) #SimpleOXPathStepPath( previous == null) */
  ASTSimpleOXPathStepPath jjtn000 = new ASTSimpleOXPathStepPath(JJTSIMPLEOXPATHSTEPPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);MyLocationPath locationPath;
  if(previous == null)
        locationPath = new MyLocationPath();
  else locationPath = previous;
    try {
      DescendantOrSelfShort();
   locationPath.appendStep(new OXPathStep(ForwardAxis.DESCENDANTORSELF,XPathNodeTest.NODE));

   if(previous==null) jjtn000.setLocationPath(locationPath);
      SimpleOXPathStepPath(locationPath);
    jjtree.closeNodeScope(jjtn000,  previous == null);
    jjtc000 = false;
   jjtn000.setHasList(locationPath.hasList());
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  previous == null);
    }
    }
  }

  final public void ComplexOXPathStepPath() throws ParseException {
  setPredicateComplex();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BEGIN_KLEENE_STAR:
      OXPathKleeneStarPath();
      break;
    case DOC_BEGIN:
    case BEGIN_URL_IN_PATH:
    case BEGIN_USER_ACTION:
      OXPathActionPath();
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void DescendantOrSelfShort() throws ParseException {
    jj_consume_token(DESCENDENT_OR_SELF_SHORT);
  }

  final public void OXPathKleeneStarPath() throws ParseException {
 /*@bgen(jjtree) OXPathKleeneStarPath */
 ASTOXPathKleeneStarPath jjtn000 = new ASTOXPathKleeneStarPath(JJTOXPATHKLEENESTARPATH);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);ArrayList<Integer> list;
    try {
      jj_consume_token(BEGIN_KLEENE_STAR);
      OXPathPathSegment();
      jj_consume_token(CLOSE_PARAN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
        jj_consume_token(MULTIPLY);
                  jjtn000.setHasLowerBound(false);jjtn000.setHasUpperBound(false);
        break;
      case BEGIN_BOUNDED_KLEENE_STAR_PRED:
        jj_consume_token(BEGIN_BOUNDED_KLEENE_STAR_PRED);
        list = OXPathKleeneStarPredicate();
        jj_consume_token(CLOSE_CURLY);
       if (list.size()>1)
        {jjtn000.setHasLowerBound(true);
         jjtn000.setHasUpperBound(true);
         jjtn000.setLowerBound(list.get(0));
         jjtn000.setUpperBound(list.get(1));}
       else {jjtn000.setHasLowerBound(true); jjtn000.setHasUpperBound(false); jjtn000.setLowerBound(list.get(0));}
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOC_BEGIN:
      case BEGIN_URL_IN_PATH:
      case DESCENDENT_OR_SELF_SHORT:
      case BEGIN_USER_ACTION:
      case BEGIN_KLEENE_STAR:
      case SLASH:
        RelativeOXPathLocationTail();
                                  jjtn000.setHasFollowingPath(true);
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public ArrayList<Integer> OXPathKleeneStarPredicate() throws ParseException {
 ArrayList<Integer> result = new ArrayList<Integer>();
 int i1;
 int i2;
    i1 = OXPathKleeneStarPredicateArg();
                                     result.add(i1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      i2 = OXPathKleeneStarPredicateArg();
                                        result.add(i2);
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
   {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public int OXPathKleeneStarPredicateArg() throws ParseException {
 Token t;
    t = jj_consume_token(DIGITS);
   {if (true) return Integer.parseInt(t.image);}
    throw new Error("Missing return statement in function");
  }

  final public void OXPathActionPath() throws ParseException {
 /*@bgen(jjtree) OXPathActionPath */
 ASTOXPathActionPath jjtn000 = new ASTOXPathActionPath(JJTOXPATHACTIONPATH);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Action action;
    try {
      action = OXPathAction();
                               jjtn000.setAction(action);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOC_BEGIN:
      case BEGIN_URL_IN_PATH:
      case DESCENDENT_OR_SELF_SHORT:
      case BEGIN_USER_ACTION:
      case BEGIN_KLEENE_STAR:
      case SLASH:
        RelativeOXPathLocationTail();
                                          jjtn000.setHasTail(true);
        break;
      default:
        jj_la1[23] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void RelativeOXPathLocationTail() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOC_BEGIN:
    case BEGIN_URL_IN_PATH:
    case BEGIN_USER_ACTION:
    case BEGIN_KLEENE_STAR:
      ComplexOXPathStepPath();
      break;
    case SLASH:
      jj_consume_token(SLASH);
      RelativeOXPathLocationPath();
      break;
    case DESCENDENT_OR_SELF_SHORT:
      AbbreviatedAbsoluteOXPathLocationPath();
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void SimpleOXPathStepPath(MyLocationPath previousLocationPath) throws ParseException {
 /*@bgen(jjtree) #SimpleOXPathStepPath( createAST) */
  ASTSimpleOXPathStepPath jjtn000 = new ASTSimpleOXPathStepPath(JJTSIMPLEOXPATHSTEPPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Step step;
  boolean createAST = false;
  MyLocationPath currentLocationPath = new MyLocationPath();
  jjtn000.setLocationPath(currentLocationPath);
  MyLocationPath carryOn = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STYLE:
      case ATTRIBUTE:
      case CHILD:
      case DESCENDANTORSELF:
      case DESCENDANT:
      case FOLLOWINGSIBLING:
      case FOLLOWING:
      case NAMESPACE:
      case SELF:
      case ANCESTORORSELF:
      case ANCESTOR:
      case PARENT:
      case PRECEDINGSIBLING:
      case PRECEDING:
      case COMMENT:
      case TEXT:
      case PROCESSING_INSTRUCTION:
      case NODE:
      case FIELD:
      case ANY_FIELD:
      case AT:
      case WILDCARD:
      case NCNAME:
        step = FullStep();
        break;
      case PERIOD:
      case PARENT_SHORT:
        step = AbbreviatedStep();
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    if(step.isPlainXPath()){//in this case we can append to an existing location path or start a new one

            if(previousLocationPath == null){//is the first step, append to the new locationpath
                createAST=true;
                        currentLocationPath.appendStep(step);
                        carryOn=currentLocationPath;
                }
                else{//we use the one under construction
                        createAST=false;
                        previousLocationPath.appendStep(step);
                        carryOn=previousLocationPath;
                        //currentLocationPath = previousLocationPath;//here we are sure we only need the previous to carry on
                }
    }
    else{//we cannot append the step to the previous (if any), but we need a new AST here
        jjtn000.setIsPlainXPath(false);
                currentLocationPath.appendStep(step);
                createAST = true;
        if(previousLocationPath != null){//we need to set haslist=true to the previousLocationPath. this AST is the list of the previous
                previousLocationPath.setHasList(true);
        }
        carryOn=null;
        }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_OPTIONAL:
      case OPEN_BRACKET:
      case DESCENDENT_OR_SELF_SHORT:
      case SLASH:
      case BEGIN_EXTRACT_MARK:
      case PERIOD_OP:
      case HASH:
        //how we go on: if the step is NOT plain xpath, on the current AST we set haslist=true
        //otherwise, it means we created or merged a locationPath, on which we set haslist=true in case of OXPathPostStepList or following complex predicates/steps 
          jjtn000.setHasList(carryOn==null);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DESCENDENT_OR_SELF_SHORT:
        case SLASH:
          SimpleOXPathStepTail(carryOn);
          break;
        case OPEN_BRACKET:
          XPathPredicate(carryOn);
          break;
        case PERIOD_OP:
        case HASH:
          OXPathNodeTestOp(carryOn);
          break;
        case OPEN_OPTIONAL:
        case BEGIN_EXTRACT_MARK:
          OXPathPostStepList();
                             if(carryOn!=null)carryOn.setHasList(true);
          break;
        default:
          jj_la1[26] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      if(carryOn!=null) jjtn000.setHasList(carryOn.hasList());
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createAST);
    }
    }
  }

  final public Step FullStep() throws ParseException {
 Axis axis = ForwardAxis.CHILD;//default unless overwritten
 NodeTest nodetest;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STYLE:
    case ATTRIBUTE:
    case CHILD:
    case DESCENDANTORSELF:
    case DESCENDANT:
    case FOLLOWINGSIBLING:
    case FOLLOWING:
    case NAMESPACE:
    case SELF:
    case ANCESTORORSELF:
    case ANCESTOR:
    case PARENT:
    case PRECEDINGSIBLING:
    case PRECEDING:
    case AT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ATTRIBUTE:
      case CHILD:
      case DESCENDANTORSELF:
      case DESCENDANT:
      case FOLLOWINGSIBLING:
      case FOLLOWING:
      case NAMESPACE:
      case SELF:
        axis = XPathForwardAxisName();
        break;
      case ANCESTORORSELF:
      case ANCESTOR:
      case PARENT:
      case PRECEDINGSIBLING:
      case PRECEDING:
        axis = XPathBackwardAxisName();
        break;
      case AT:
        axis = XPathAbbreviatedAxisSpecifier();
        break;
      case STYLE:
        axis = OXPathAxisSpecifier();
        break;
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[29] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMENT:
    case TEXT:
    case PROCESSING_INSTRUCTION:
    case NODE:
    case WILDCARD:
    case NCNAME:
      nodetest = XPathNodeTest();
      break;
    case FIELD:
    case ANY_FIELD:
      nodetest = OXPathNodeTest();
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                                               {if (true) return new OXPathStep(axis,nodetest);}
    throw new Error("Missing return statement in function");
  }

  final public void OXPathPostStepList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_OPTIONAL:
      OXPathOptionalPredicate();
      break;
    case BEGIN_EXTRACT_MARK:
      OXPathExtractionMarker();
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void OXPathPostStepListOrPredicate() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PERIOD_OP:
    case HASH:
      OXPathNodeTestOp(null);
      break;
    case OPEN_BRACKET:
      XPathPredicate(null);
      break;
    case OPEN_OPTIONAL:
      OXPathOptionalPredicate();
      break;
    case BEGIN_EXTRACT_MARK:
      OXPathExtractionMarker();
      break;
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public Axis OXPathAxisSpecifier() throws ParseException {
 Axis a;
setPredicateComplex();
    a = OXPathAxisName();
                      {if (true) return a;}
    throw new Error("Missing return statement in function");
  }

  final public Axis XPathForwardAxisName() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ATTRIBUTE:
      jj_consume_token(ATTRIBUTE);
                 {if (true) return ForwardAxis.ATTRIBUTE;}
      break;
    case CHILD:
      jj_consume_token(CHILD);
             {if (true) return ForwardAxis.CHILD;}
      break;
    case DESCENDANTORSELF:
      jj_consume_token(DESCENDANTORSELF);
                        {if (true) return ForwardAxis.DESCENDANTORSELF;}
      break;
    case DESCENDANT:
      jj_consume_token(DESCENDANT);
                  {if (true) return ForwardAxis.DESCENDANT;}
      break;
    case FOLLOWINGSIBLING:
      jj_consume_token(FOLLOWINGSIBLING);
                        {if (true) return ForwardAxis.FOLLOWINGSIBLING;}
      break;
    case FOLLOWING:
      jj_consume_token(FOLLOWING);
                 {if (true) return ForwardAxis.FOLLOWING;}
      break;
    case NAMESPACE:
      jj_consume_token(NAMESPACE);
                 {if (true) return ForwardAxis.NAMESPACE;}
      break;
    case SELF:
      jj_consume_token(SELF);
            {if (true) return ForwardAxis.SELF;}
      break;
    default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Axis XPathBackwardAxisName() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ANCESTORORSELF:
      jj_consume_token(ANCESTORORSELF);
                      {if (true) return BackwardAxis.ANCESTORORSELF;}
      break;
    case ANCESTOR:
      jj_consume_token(ANCESTOR);
                {if (true) return BackwardAxis.ANCESTOR;}
      break;
    case PARENT:
      jj_consume_token(PARENT);
              {if (true) return BackwardAxis.PARENT;}
      break;
    case PRECEDINGSIBLING:
      jj_consume_token(PRECEDINGSIBLING);
                        {if (true) return BackwardAxis.PRECEDINGSIBLING;}
      break;
    case PRECEDING:
      jj_consume_token(PRECEDING);
                 {if (true) return BackwardAxis.PRECEDING;}
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Axis OXPathAxisName() throws ParseException {
    jj_consume_token(STYLE);
             {if (true) return OXPathAxis.STYLE;}
    throw new Error("Missing return statement in function");
  }

  final public Axis XPathAbbreviatedAxisSpecifier() throws ParseException {
    jj_consume_token(AT);
          {if (true) return AbbreviatedAxis.AT;}
    throw new Error("Missing return statement in function");
  }

  final public NodeTest XPathNodeTest() throws ParseException {
 NodeTest nt;
 String parameter = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WILDCARD:
    case NCNAME:
      nt = XPathNameTest();
                      {if (true) return nt;}
      break;
    case COMMENT:
      jj_consume_token(COMMENT);
      jj_consume_token(CLOSE_PARAN);
                               {if (true) return XPathNodeTest.COMMENT;}
      break;
    case TEXT:
      jj_consume_token(TEXT);
      jj_consume_token(CLOSE_PARAN);
                            {if (true) return XPathNodeTest.TEXT;}
      break;
    case PROCESSING_INSTRUCTION:
      jj_consume_token(PROCESSING_INSTRUCTION);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOUBLE_QUOTE_STRING_PATH:
      case SINGLE_QUOTE_STRING_PATH:
        parameter = XPathLiteral(false);
        break;
      default:
        jj_la1[35] = jj_gen;
        ;
      }
      jj_consume_token(CLOSE_PARAN);
                                                                              {if (true) return (parameter.equals(""))?XPathNodeTest.PROCESSINGINSTRUCTION:new ParameterizedProcessingInstruction(parameter);}
      break;
    case NODE:
      jj_consume_token(NODE);
      jj_consume_token(CLOSE_PARAN);
                            {if (true) return XPathNodeTest.NODE;}
      break;
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public NodeTest OXPathNodeTest() throws ParseException {
 NodeTest nodetest;setPredicateComplex();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FIELD:
      jj_consume_token(FIELD);
               nodetest=OXPathNodeTest.FIELD;
      break;
    case ANY_FIELD:
      jj_consume_token(ANY_FIELD);
                                                                nodetest=OXPathNodeTest.ANYFIELD;
      break;
    default:
      jj_la1[37] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(CLOSE_PARAN);
   {if (true) return nodetest;}
    throw new Error("Missing return statement in function");
  }

  final public void OXPathNodeTestOp(MyLocationPath previous) throws ParseException {
 /*@bgen(jjtree) #OXPathNodeTestOp( createAST) */
 ASTOXPathNodeTestOp jjtn000 = new ASTOXPathNodeTestOp(JJTOXPATHNODETESTOP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Selector select;
 Token value;
 boolean createAST = previous==null;
    try {
      select = OXPathNodeTestOper();
      value = jj_consume_token(NCNAME);
    SelectorPredicate selPred = new SelectorPredicate(select,value.image);
        jjtn000.setSelectorPredicate(selPred);
        if(previous!=null){
    previous.addSelectorPredicate(selPred);
    cleanScopeForPredicate();//removes from the stack the children nodes not needed 
        }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_OPTIONAL:
      case OPEN_BRACKET:
      case DESCENDENT_OR_SELF_SHORT:
      case SLASH:
      case BEGIN_EXTRACT_MARK:
      case PERIOD_OP:
      case HASH:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DESCENDENT_OR_SELF_SHORT:
        case SLASH:
          SimpleOXPathStepTail(previous);
          break;
        case OPEN_BRACKET:
          XPathPredicate(previous);
          break;
        case PERIOD_OP:
        case HASH:
          OXPathNodeTestOp(previous);
          break;
        case OPEN_OPTIONAL:
        case BEGIN_EXTRACT_MARK:
          OXPathPostStepList();
                           if(previous!=null) previous.setHasList(true);
          break;
        default:
          jj_la1[38] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
   if(createAST) jjtn000.setHasList(true);
        break;
      default:
        jj_la1[39] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createAST);
    }
    }
  }

  final public Selector OXPathNodeTestOper() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PERIOD_OP:
      jj_consume_token(PERIOD_OP);
                 {if (true) return Selector.CLASS;}
      break;
    case HASH:
      jj_consume_token(HASH);
            {if (true) return Selector.ID;}
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public XPathNameTest XPathNameTest() throws ParseException {
 Token tp;
 Token ts;
 NodeTest nt;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WILDCARD:
      ts = jj_consume_token(WILDCARD);
                   {if (true) return new XPathNameTest(ts.image,true);}
      break;
    case NCNAME:
      tp = jj_consume_token(NCNAME);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLON:
        jj_consume_token(COLON);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WILDCARD:
          ts = jj_consume_token(WILDCARD);
                     {if (true) return new XPathNameTest(tp.image,ts.image,true);}
          break;
        case NCNAME:
          ts = jj_consume_token(NCNAME);
                   {if (true) return new XPathNameTest(tp.image,ts.image,false);}
          break;
        default:
          jj_la1[41] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[42] = jj_gen;
        ;
      }
   {if (true) return new XPathNameTest(tp.image,false);}
      break;
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathLiteral(boolean node) throws ParseException {
 /*@bgen(jjtree) #XPathLiteral( node) */
 ASTXPathLiteral jjtn000 = new ASTXPathLiteral(JJTXPATHLITERAL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOUBLE_QUOTE_STRING_PATH:
        t = jj_consume_token(DOUBLE_QUOTE_STRING_PATH);
                                       jjtree.closeNodeScope(jjtn000,  node);
                                       jjtc000 = false;
                                      jjtn000.setValue(t.image); {if (true) return jjtn000.getValue();}
        break;
      case SINGLE_QUOTE_STRING_PATH:
        t = jj_consume_token(SINGLE_QUOTE_STRING_PATH);
                                       jjtree.closeNodeScope(jjtn000,  node);
                                       jjtc000 = false;
                                      jjtn000.setValue(t.image); {if (true) return jjtn000.getValue();}
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  node);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void XPathPredicate(MyLocationPath previousLocationPath) throws ParseException {
 /*@bgen(jjtree) #XPathPredicate( createAST) */
ASTXPathPredicate jjtn000 = new ASTXPathPredicate(JJTXPATHPREDICATE);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);boolean containsComplexPart = false;
boolean hasLeadingPath = false;
if (previousLocationPath != null) {
      hasLeadingPath = openNewPredicateWatcher();
}
boolean createAST = true;
MyLocationPath currentLocationPath = previousLocationPath;
    try {
      jj_consume_token(OPEN_BRACKET);
      XPathExpr();
      jj_consume_token(CLOSE_BRACKET);
        if (hasLeadingPath) {//try to append the predicate to the leading path if doesn't contain not-plain xpath stuff
        containsComplexPart = closePredicateWatcher();
        if (!containsComplexPart) {
          previousLocationPath.addPredicate(jjtree.peekNode());
          createAST = false;
          cleanScopeForPredicate();//removes from the stack the children nodes not needed 
        } else {
          previousLocationPath.setHasList(true);
          currentLocationPath = null; // to break collapsing the following if the current is not collapsed
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_OPTIONAL:
      case OPEN_BRACKET:
      case DESCENDENT_OR_SELF_SHORT:
      case SLASH:
      case BEGIN_EXTRACT_MARK:
      case PERIOD_OP:
      case HASH:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DESCENDENT_OR_SELF_SHORT:
        case SLASH:
          SimpleOXPathStepTail(currentLocationPath);
          break;
        case OPEN_BRACKET:
          XPathPredicate(currentLocationPath);
          break;
        case PERIOD_OP:
        case HASH:
          OXPathNodeTestOp(currentLocationPath);
          break;
        case OPEN_OPTIONAL:
        case BEGIN_EXTRACT_MARK:
          OXPathPostStepList();
                           if(previousLocationPath!=null) previousLocationPath.setHasList(true);
          break;
        default:
          jj_la1[45] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
    if(createAST) jjtn000.setHasList(true);
        break;
      default:
        jj_la1[46] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createAST);
    }
    }
  }

  final public void OXPathOptionalPredicate() throws ParseException {
 /*@bgen(jjtree) XPathPredicate */
 ASTXPathPredicate jjtn000 = new ASTXPathPredicate(JJTXPATHPREDICATE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);setPredicateComplex();
    try {
      jj_consume_token(OPEN_OPTIONAL);
                     jjtn000.setIsOptional(true);
      XPathExpr();
      jj_consume_token(CLOSE_BRACKET);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_OPTIONAL:
      case OPEN_BRACKET:
      case DESCENDENT_OR_SELF_SHORT:
      case SLASH:
      case BEGIN_EXTRACT_MARK:
      case PERIOD_OP:
      case HASH:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DESCENDENT_OR_SELF_SHORT:
        case SLASH:
          SimpleOXPathStepTail(null);
          break;
        case OPEN_OPTIONAL:
        case OPEN_BRACKET:
        case BEGIN_EXTRACT_MARK:
        case PERIOD_OP:
        case HASH:
          OXPathPostStepListOrPredicate();
          break;
        default:
          jj_la1[47] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                                                    jjtn000.setHasList(true);
        break;
      default:
        jj_la1[48] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public Action OXPathAction() throws ParseException {
 Action a;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOC_BEGIN:
    case BEGIN_URL_IN_PATH:
      a = OXPathURLAction();
      break;
    case BEGIN_USER_ACTION:
      a = OXPathUserAction();
      break;
    default:
      jj_la1[49] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
   {if (true) return a;}
    throw new Error("Missing return statement in function");
  }

  final public Action OXPathURLAction() throws ParseException {
 Action a;
 String s;
 long l;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BEGIN_URL_IN_PATH:
      jj_consume_token(BEGIN_URL_IN_PATH);
      s = URLName();
      jj_consume_token(END_URL_IN_PATH);
   a= new URLAction(s);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
        OXPathActionPred(a);
        break;
      default:
        jj_la1[50] = jj_gen;
        ;
      }
      jj_consume_token(SLASH);
      jj_consume_token(CLOSE_CURLY);
      break;
    case DOC_BEGIN:
      jj_consume_token(DOC_BEGIN);
      s = XPathLiteral(false);
   a= new URLAction(s);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        OXPathActionPred(a);
        break;
      default:
        jj_la1[51] = jj_gen;
        ;
      }
      jj_consume_token(CLOSE_PARAN);
   {if (true) return a;}
      break;
    default:
      jj_la1[52] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Action OXPathUserAction() throws ParseException {
 Action a;
 long l;
    jj_consume_token(BEGIN_USER_ACTION);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIGITS:
      a = GroundedOXPathActionPosition();
      break;
    case DOUBLE_QUOTE_STRING_PATH:
    case SINGLE_QUOTE_STRING_PATH:
      a = GroundedOXPathActionExplicit();
      break;
    case FOCUS:
    case CLICK:
    case NEXTCLICK:
    case PRESSENTER:
    case CLICKWITHCHANGE:
    case MOVETOFRAME:
    case ENTERFRAME:
    case MOVETOHREF:
    case DBLCLICK:
    case MOUSEDOWN:
    case MOUSEENTER:
    case MOUSEMOVE:
    case MOUSEOVER:
    case MOUSEOUT:
    case MOUSEUP:
    case WHEEL:
    case SUBMIT:
    case CHECK:
    case UNCHECK:
      a = OXPathActionKeyword();
      break;
    case VARIABLE:
      a = OXPathActionVariable();
      break;
    default:
      jj_la1[53] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACKET:
      OXPathActionPred(a);
      break;
    default:
      jj_la1[54] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SLASH:
      OXPathAbsoluteActionSignal();
                                  a.setIsAbsoluteAction(true);
      break;
    default:
      jj_la1[55] = jj_gen;
      ;
    }
    jj_consume_token(CLOSE_CURLY);
   {if (true) return a;}
    throw new Error("Missing return statement in function");
  }

  final public void OXPathActionPred(Action a) throws ParseException {
    jj_consume_token(OPEN_BRACKET);
    OXPathActionPredList(a);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[56] = jj_gen;
        break label_2;
      }
      jj_consume_token(COMMA);
      OXPathActionPredList(a);
    }
    jj_consume_token(CLOSE_BRACKET);
  }

  final public void OXPathActionPredList(Action a) throws ParseException {
 long wait;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WAIT:
      wait = OXPathActionWaitPred();
                                 a.setWait(wait);
      break;
    case NOBACK:
      jj_consume_token(NOBACK);
     a.isBackActionNeeded(false);
      break;
    default:
      jj_la1[57] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public long OXPathActionWaitPred() throws ParseException {
 Token wait;
    jj_consume_token(WAIT);
    wait = jj_consume_token(DIGITS);
   {if (true) return Long.parseLong(wait.image);}
    throw new Error("Missing return statement in function");
  }

  final public void OXPathAbsoluteActionSignal() throws ParseException {
    jj_consume_token(SLASH);
  }

  final public Action GroundedOXPathActionPosition() throws ParseException {
 Token t;
    t = jj_consume_token(DIGITS);
                {if (true) return new PositionAction(Integer.parseInt(t.image));}
    throw new Error("Missing return statement in function");
  }

  final public Action GroundedOXPathActionExplicit() throws ParseException {
 String s;
    s = XPathLiteral(false);
                         {if (true) return new ExplicitAction(s);}
    throw new Error("Missing return statement in function");
  }

  final public Action OXPathActionKeyword() throws ParseException {
 Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FOCUS:
      t = jj_consume_token(FOCUS);
               {if (true) return new KeywordAction(ActionKeywords.FOCUS);}
      break;
    case CLICK:
      t = jj_consume_token(CLICK);
               {if (true) return new KeywordAction(ActionKeywords.CLICK);}
      break;
    case CLICKWITHCHANGE:
      t = jj_consume_token(CLICKWITHCHANGE);
                         {if (true) return new KeywordAction(ActionKeywords.CLICKWITHCHANGE);}
      break;
    case NEXTCLICK:
      t = jj_consume_token(NEXTCLICK);
                   {if (true) return new KeywordAction(ActionKeywords.NEXTCLICK);}
      break;
    case PRESSENTER:
      t = jj_consume_token(PRESSENTER);
                    {if (true) return new KeywordAction(ActionKeywords.PRESSENTER);}
      break;
    case ENTERFRAME:
      t = jj_consume_token(ENTERFRAME);
                    {if (true) return new KeywordAction(ActionKeywords.ENTERFRAME);}
      break;
    case MOVETOFRAME:
      t = jj_consume_token(MOVETOFRAME);
                     {if (true) return new KeywordAction(ActionKeywords.MOVETOFRAME);}
      break;
    case MOVETOHREF:
      t = jj_consume_token(MOVETOHREF);
                    {if (true) return new KeywordAction(ActionKeywords.MOVETOHREF);}
      break;
    case DBLCLICK:
      t = jj_consume_token(DBLCLICK);
                  {if (true) return new KeywordAction(ActionKeywords.DBLCLICK);}
      break;
    case MOUSEDOWN:
      t = jj_consume_token(MOUSEDOWN);
                   {if (true) return new KeywordAction(ActionKeywords.MOUSEDOWN);}
      break;
    case MOUSEENTER:
      t = jj_consume_token(MOUSEENTER);
                    {if (true) return new KeywordAction(ActionKeywords.MOUSEENTER);}
      break;
    case MOUSEMOVE:
      t = jj_consume_token(MOUSEMOVE);
                   {if (true) return new KeywordAction(ActionKeywords.MOUSEMOVE);}
      break;
    case MOUSEOVER:
      t = jj_consume_token(MOUSEOVER);
                   {if (true) return new KeywordAction(ActionKeywords.MOUSEOVER);}
      break;
    case MOUSEOUT:
      t = jj_consume_token(MOUSEOUT);
                  {if (true) return new KeywordAction(ActionKeywords.MOUSEOUT);}
      break;
    case MOUSEUP:
      t = jj_consume_token(MOUSEUP);
                 {if (true) return new KeywordAction(ActionKeywords.MOUSEUP);}
      break;
    case WHEEL:
      t = jj_consume_token(WHEEL);
               {if (true) return new KeywordAction(ActionKeywords.WHEEL);}
      break;
    case SUBMIT:
      t = jj_consume_token(SUBMIT);
                {if (true) return new KeywordAction(ActionKeywords.SUBMIT);}
      break;
    case CHECK:
      t = jj_consume_token(CHECK);
               {if (true) return new KeywordAction(ActionKeywords.CHECK);}
      break;
    case UNCHECK:
      t = jj_consume_token(UNCHECK);
                 {if (true) return new KeywordAction(ActionKeywords.UNCHECK);}
      break;
    default:
      jj_la1[58] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Action OXPathActionVariable() throws ParseException {
 Token t;
    t = jj_consume_token(VARIABLE);
                  {if (true) return new VariableAction(t.image);}
    throw new Error("Missing return statement in function");
  }

  final public void OXPathExtractionMarker() throws ParseException {
 /*@bgen(jjtree) OXPathExtractionMarker */
 ASTOXPathExtractionMarker jjtn000 = new ASTOXPathExtractionMarker(JJTOXPATHEXTRACTIONMARKER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String s; OXPathExtractionMarker marker;
setPredicateComplex();
    try {
      jj_consume_token(BEGIN_EXTRACT_MARK);
      s = OXPathExtractionName();
                             marker=new OXPathExtractionMarker(s,false);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PARAN:
      case EQUALS:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_PARAN:
          jj_consume_token(OPEN_PARAN);
          s = OXPathExtractionName();
                                              marker.addRdfType(s);
          label_3:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[59] = jj_gen;
              break label_3;
            }
            jj_consume_token(COMMA);
            s = OXPathExtractionName();
                                           marker.addRdfType(s);
          }
          jj_consume_token(CLOSE_PARAN);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EQUALS:
            jj_consume_token(EQUALS);
            OXPathExtractionValue();
                                                          marker.setAttribute(true);
            break;
          default:
            jj_la1[60] = jj_gen;
            ;
          }
          break;
        case EQUALS:
          jj_consume_token(EQUALS);
          OXPathExtractionValue();
                                         marker.setAttribute(true);
          break;
        default:
          jj_la1[61] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[62] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case END_EXTRACT_MARK:
        jj_consume_token(END_EXTRACT_MARK);
        break;
      case GREATER:
        jj_consume_token(GREATER);
        break;
      default:
        jj_la1[63] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
   jjtn000.setExtractionMarker(marker);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_OPTIONAL:
      case OPEN_BRACKET:
      case DESCENDENT_OR_SELF_SHORT:
      case SLASH:
      case BEGIN_EXTRACT_MARK:
      case PERIOD_OP:
      case HASH:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DESCENDENT_OR_SELF_SHORT:
        case SLASH:
          SimpleOXPathStepTail(null);
          break;
        case OPEN_OPTIONAL:
        case OPEN_BRACKET:
        case BEGIN_EXTRACT_MARK:
        case PERIOD_OP:
        case HASH:
          OXPathPostStepListOrPredicate();
          break;
        default:
          jj_la1[64] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                                                    jjtn000.setHasList(true);
        break;
      default:
        jj_la1[65] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public String OXPathExtractionName() throws ParseException {
 Token t; String s;
    // PRE RDF Code:
    //  t=< NCNAME > {return t.image;}
    
    // We allow now colons in the name for namespace separation.
      t = jj_consume_token(NCNAME);
                 s=t.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      t = jj_consume_token(NCNAME);
                             s=s+":"+t.image;
      break;
    default:
      jj_la1[66] = jj_gen;
      ;
    }
    {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public void OXPathExtractionValue() throws ParseException {
    XPathPrimaryExpr();
  }

  final public void XPathExpr() throws ParseException {
    XPathOrExpr();
  }

  final public void XPathOrExpr() throws ParseException {
 /*@bgen(jjtree) #BinaryOpExpr(> 1) */
  ASTBinaryOpExpr jjtn000 = new ASTBinaryOpExpr(JJTBINARYOPEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      XPathAndExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        jj_consume_token(OR);
                           jjtn000.setBinaryOperator(HigherLevelOp.OR);
        XPathOrExpr();
        break;
      default:
        jj_la1[67] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public void XPathAndExpr() throws ParseException {
 /*@bgen(jjtree) #BinaryOpExpr(> 1) */
  ASTBinaryOpExpr jjtn000 = new ASTBinaryOpExpr(JJTBINARYOPEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      XPathEqualityExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        jj_consume_token(AND);
                                 jjtn000.setBinaryOperator(HigherLevelOp.AND);
        XPathAndExpr();
        break;
      default:
        jj_la1[68] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public void XPathEqualityExpr() throws ParseException {
 /*@bgen(jjtree) #BinaryOpExpr(> 1) */
 ASTBinaryOpExpr jjtn000 = new ASTBinaryOpExpr(JJTBINARYOPEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);EqualityExprOp op;
    try {
      XPathRelationalExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOTEQUAL:
      case EQUALS:
      case WORD_TEST:
      case CONTAINS:
        op = XPathEqualityExprOp();
                               jjtn000.setBinaryOperator(op);
        XPathEqualityExpr();
        break;
      default:
        jj_la1[69] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public EqualityExprOp XPathEqualityExprOp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUALS:
      jj_consume_token(EQUALS);
              {if (true) return EqualityExprOp.EQUALS;}
      break;
    case NOTEQUAL:
      jj_consume_token(NOTEQUAL);
                {if (true) return EqualityExprOp.NOTEQUAL;}
      break;
    case WORD_TEST:
      jj_consume_token(WORD_TEST);
                  {if (true) return EqualityExprOp.WORDTEST;}
      break;
    case CONTAINS:
      jj_consume_token(CONTAINS);
                 {if (true) return EqualityExprOp.CONTAINS;}
      break;
    default:
      jj_la1[70] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void XPathRelationalExpr() throws ParseException {
 /*@bgen(jjtree) #BinaryOpExpr(> 1) */
 ASTBinaryOpExpr jjtn000 = new ASTBinaryOpExpr(JJTBINARYOPEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);RelationalExprOp op;
    try {
      XPathAdditiveExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LESSTE:
      case LESS:
      case GREATERTE:
      case GREATER:
        op = XPathRelationalExprOp();
                                jjtn000.setBinaryOperator(op);
        XPathRelationalExpr();
        break;
      default:
        jj_la1[71] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public RelationalExprOp XPathRelationalExprOp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GREATER:
      jj_consume_token(GREATER);
               {if (true) return RelationalExprOp.GREATER;}
      break;
    case LESS:
      jj_consume_token(LESS);
            {if (true) return RelationalExprOp.LESS;}
      break;
    case GREATERTE:
      jj_consume_token(GREATERTE);
                 {if (true) return RelationalExprOp.GREATERTE;}
      break;
    case LESSTE:
      jj_consume_token(LESSTE);
              {if (true) return RelationalExprOp.LESSTE;}
      break;
    default:
      jj_la1[72] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void XPathAdditiveExpr() throws ParseException {
 /*@bgen(jjtree) #BinaryOpExpr(> 1) */
 ASTBinaryOpExpr jjtn000 = new ASTBinaryOpExpr(JJTBINARYOPEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);AdditiveExprOp op;
    try {
      XPathMultiplicativeExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        op = AdditiveExprOp();
                         jjtn000.setBinaryOperator(op);
        XPathAdditiveExpr();
        break;
      default:
        jj_la1[73] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public AdditiveExprOp AdditiveExprOp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      jj_consume_token(PLUS);
            {if (true) return AdditiveExprOp.PLUS;}
      break;
    case MINUS:
      jj_consume_token(MINUS);
             {if (true) return AdditiveExprOp.MINUS;}
      break;
    default:
      jj_la1[74] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void XPathMultiplicativeExpr() throws ParseException {
 /*@bgen(jjtree) #BinaryOpExpr(> 1) */
 ASTBinaryOpExpr jjtn000 = new ASTBinaryOpExpr(JJTBINARYOPEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);MultiplicativeExprOp op;
    try {
      XPathUnaryExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MOD:
      case DIV:
      case MULTIPLY:
        op = MultiplicativeExprOp();
                               jjtn000.setBinaryOperator(op);
        XPathMultiplicativeExpr();
        break;
      default:
        jj_la1[75] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public MultiplicativeExprOp MultiplicativeExprOp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MULTIPLY:
      jj_consume_token(MULTIPLY);
                {if (true) return MultiplicativeExprOp.MULTIPLY;}
      break;
    case DIV:
      jj_consume_token(DIV);
           {if (true) return MultiplicativeExprOp.DIV;}
      break;
    case MOD:
      jj_consume_token(MOD);
           {if (true) return MultiplicativeExprOp.MOD;}
      break;
    default:
      jj_la1[76] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void XPathUnaryExpr() throws ParseException {
 /*@bgen(jjtree) #XPathUnaryExpr( hasOp) */
 ASTXPathUnaryExpr jjtn000 = new ASTXPathUnaryExpr(JJTXPATHUNARYEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);boolean hasOp = false;
    try {
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NEGATIVE:
          ;
          break;
        default:
          jj_la1[77] = jj_gen;
          break label_4;
        }
        XPathUnaryExprOp();
                        jjtn000.incrementOperatorNumber(); hasOp=true;
      }
      XPathUnionExpr();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  hasOp);
    }
    }
  }

  final public void XPathUnaryExprOp() throws ParseException {
    jj_consume_token(NEGATIVE);
  }

  final public void XPathPrimaryExpr() throws ParseException {
 /*@bgen(jjtree) #XPathPrimaryExpr( parans) */
 ASTXPathPrimaryExpr jjtn000 = new ASTXPathPrimaryExpr(JJTXPATHPRIMARYEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);boolean parans = false;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PARAN:
        jj_consume_token(OPEN_PARAN);
                  parans=true;
        XPathExpr();
        jj_consume_token(CLOSE_PARAN);
        break;
      case DOUBLE_QUOTE_STRING_PATH:
      case SINGLE_QUOTE_STRING_PATH:
        XPathLiteral(true);
        break;
      case NUMBER:
      case DIGITS:
        XPathNumber();
        break;
      case POSITION:
      case LAST:
      case COUNT:
      case ID:
      case NAMESPACEURI:
      case LOCALNAME:
      case NAME:
      case STRING:
      case CONCAT:
      case STARTSWITH:
      case CONTAINSFUNC:
      case MINUS_FUNC:
      case PLUS_FUNC:
      case SUBSTRINGBEFORE:
      case SUBSTRINGAFTER:
      case SUBSTRING:
      case SUBSTRINGLENGTH:
      case NORMALIZESPACE:
      case TRANSLATE:
      case SUBSTRINGBEFOREREVERSE:
      case SUBSTRINGAFTERREVERSE:
      case SUBSTRINGREVERSE:
      case STRINGJOIN:
      case REPLACE:
      case QUALIFYURL:
      case ISVISIBLE:
      case ISINVISIBLE:
      case TOXML:
      case DOMPROPERTY:
      case SELECTTEXT:
      case INNERHTML:
      case OUTERHTML:
      case CURRENTURL:
      case PAGECONTENT:
      case SCREENSHOT:
      case SAVEPAGE:
      case NOW:
      case URIFY:
      case JAROWRINKLER:
      case BOOLEAN:
      case NOT:
      case TRUE:
      case FALSE:
      case LANG:
      case NUMBERFUNC:
      case SUM:
      case FLOOR:
      case CEILING:
      case ROUND:
        XPathFunctionCall();
        break;
      default:
        jj_la1[78] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  parans);
    }
    }
  }

  final public double XPathNumber() throws ParseException {
 /*@bgen(jjtree) XPathNumber */
 ASTXPathNumber jjtn000 = new ASTXPathNumber(JJTXPATHNUMBER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMBER:
        t = jj_consume_token(NUMBER);
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                jjtn000.setValue(Double.parseDouble(t.image)); {if (true) return jjtn000.getValue();}
        break;
      case DIGITS:
        t = jj_consume_token(DIGITS);
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                jjtn000.setValue(Double.parseDouble(t.image)); {if (true) return jjtn000.getValue();}
        break;
      default:
        jj_la1[79] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void XPathFunctionCall() throws ParseException {
 /*@bgen(jjtree) XPathFunctionCall */
 ASTXPathFunctionCall jjtn000 = new ASTXPathFunctionCall(JJTXPATHFUNCTIONCALL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);XPathFunction function;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POSITION:
      case LAST:
      case COUNT:
      case ID:
      case NAMESPACEURI:
      case LOCALNAME:
      case NAME:
      case STRING:
      case CONCAT:
      case STARTSWITH:
      case CONTAINSFUNC:
      case SUBSTRINGBEFORE:
      case SUBSTRINGAFTER:
      case SUBSTRING:
      case SUBSTRINGLENGTH:
      case NORMALIZESPACE:
      case TRANSLATE:
      case BOOLEAN:
      case NOT:
      case TRUE:
      case FALSE:
      case LANG:
      case NUMBERFUNC:
      case SUM:
      case FLOOR:
      case CEILING:
      case ROUND:
        function = XPathFunctionCallName();
        break;
      case MINUS_FUNC:
      case PLUS_FUNC:
      case SUBSTRINGBEFOREREVERSE:
      case SUBSTRINGAFTERREVERSE:
      case SUBSTRINGREVERSE:
      case STRINGJOIN:
      case REPLACE:
      case QUALIFYURL:
      case ISVISIBLE:
      case ISINVISIBLE:
      case TOXML:
      case DOMPROPERTY:
      case SELECTTEXT:
      case INNERHTML:
      case OUTERHTML:
      case CURRENTURL:
      case PAGECONTENT:
      case SCREENSHOT:
      case SAVEPAGE:
      case NOW:
      case URIFY:
      case JAROWRINKLER:
        function = XPathUserFunctionCallName();
        break;
      default:
        jj_la1[80] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     jjtn000.setFunction(function);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOC_BEGIN:
      case OPEN_PARAN:
      case BEGIN_URL_IN_PATH:
      case NUMBER:
      case DESCENDENT_OR_SELF_SHORT:
      case BEGIN_USER_ACTION:
      case BEGIN_KLEENE_STAR:
      case SLASH:
      case STYLE:
      case ATTRIBUTE:
      case CHILD:
      case DESCENDANTORSELF:
      case DESCENDANT:
      case FOLLOWINGSIBLING:
      case FOLLOWING:
      case NAMESPACE:
      case SELF:
      case ANCESTORORSELF:
      case ANCESTOR:
      case PARENT:
      case PRECEDINGSIBLING:
      case PRECEDING:
      case COMMENT:
      case TEXT:
      case PROCESSING_INSTRUCTION:
      case NODE:
      case FIELD:
      case ANY_FIELD:
      case PERIOD:
      case PARENT_SHORT:
      case AT:
      case POSITION:
      case LAST:
      case COUNT:
      case ID:
      case NAMESPACEURI:
      case LOCALNAME:
      case NAME:
      case STRING:
      case CONCAT:
      case STARTSWITH:
      case CONTAINSFUNC:
      case MINUS_FUNC:
      case PLUS_FUNC:
      case SUBSTRINGBEFORE:
      case SUBSTRINGAFTER:
      case SUBSTRING:
      case SUBSTRINGLENGTH:
      case NORMALIZESPACE:
      case TRANSLATE:
      case SUBSTRINGBEFOREREVERSE:
      case SUBSTRINGAFTERREVERSE:
      case SUBSTRINGREVERSE:
      case STRINGJOIN:
      case REPLACE:
      case QUALIFYURL:
      case ISVISIBLE:
      case ISINVISIBLE:
      case TOXML:
      case DOMPROPERTY:
      case SELECTTEXT:
      case INNERHTML:
      case OUTERHTML:
      case CURRENTURL:
      case PAGECONTENT:
      case SCREENSHOT:
      case SAVEPAGE:
      case NOW:
      case URIFY:
      case JAROWRINKLER:
      case BOOLEAN:
      case NOT:
      case TRUE:
      case FALSE:
      case LANG:
      case NUMBERFUNC:
      case SUM:
      case FLOOR:
      case CEILING:
      case ROUND:
      case NEGATIVE:
      case WILDCARD:
      case NCNAME:
      case DIGITS:
      case DOUBLE_QUOTE_STRING_PATH:
      case SINGLE_QUOTE_STRING_PATH:
        XPathArgument();
                     jjtn000.addParameter();
        label_5:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[81] = jj_gen;
            break label_5;
          }
          jj_consume_token(COMMA);
          XPathArgument();
                                                                           jjtn000.addParameter();
        }
        break;
      default:
        jj_la1[82] = jj_gen;
        ;
      }
      jj_consume_token(CLOSE_PARAN);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public XPathFunction XPathFunctionCallName() throws ParseException {
 Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POSITION:
      jj_consume_token(POSITION);
                {if (true) return XPathFunctions.POSITION;}
      break;
    case LAST:
      jj_consume_token(LAST);
            {if (true) return XPathFunctions.LAST;}
      break;
    case COUNT:
      jj_consume_token(COUNT);
             {if (true) return XPathFunctions.COUNT;}
      break;
    case ID:
      jj_consume_token(ID);
          {if (true) return XPathFunctions.ID;}
      break;
    case LOCALNAME:
      jj_consume_token(LOCALNAME);
                 {if (true) return XPathFunctions.LOCALNAME;}
      break;
    case NAMESPACEURI:
      jj_consume_token(NAMESPACEURI);
                    {if (true) return XPathFunctions.NAMESPACEURI;}
      break;
    case NAME:
      jj_consume_token(NAME);
            {if (true) return XPathFunctions.NAME;}
      break;
    case STRING:
      jj_consume_token(STRING);
              {if (true) return XPathFunctions.STRING;}
      break;
    case CONCAT:
      jj_consume_token(CONCAT);
              {if (true) return XPathFunctions.CONCAT;}
      break;
    case STARTSWITH:
      jj_consume_token(STARTSWITH);
                  {if (true) return XPathFunctions.STARTSWITH;}
      break;
    case CONTAINSFUNC:
      jj_consume_token(CONTAINSFUNC);
                    {if (true) return XPathFunctions.CONTAINS;}
      break;
    case SUBSTRINGBEFORE:
      jj_consume_token(SUBSTRINGBEFORE);
                       {if (true) return XPathFunctions.SUBSTRINGBEFORE;}
      break;
    case SUBSTRINGAFTER:
      jj_consume_token(SUBSTRINGAFTER);
                      {if (true) return XPathFunctions.SUBSTRINGAFTER;}
      break;
    case SUBSTRING:
      jj_consume_token(SUBSTRING);
                 {if (true) return XPathFunctions.SUBSTRING;}
      break;
    case SUBSTRINGLENGTH:
      jj_consume_token(SUBSTRINGLENGTH);
                        {if (true) return XPathFunctions.SUBSTRINGLENGTH;}
      break;
    case NORMALIZESPACE:
      jj_consume_token(NORMALIZESPACE);
                      {if (true) return XPathFunctions.NORMALIZESPACE;}
      break;
    case TRANSLATE:
      jj_consume_token(TRANSLATE);
                 {if (true) return XPathFunctions.TRANSLATE;}
      break;
    case BOOLEAN:
      jj_consume_token(BOOLEAN);
               {if (true) return XPathFunctions.BOOLEAN;}
      break;
    case NOT:
      jj_consume_token(NOT);
           {if (true) return XPathFunctions.NOT;}
      break;
    case TRUE:
      jj_consume_token(TRUE);
            {if (true) return XPathFunctions.TRUE;}
      break;
    case FALSE:
      jj_consume_token(FALSE);
             {if (true) return XPathFunctions.FALSE;}
      break;
    case LANG:
      jj_consume_token(LANG);
            {if (true) return XPathFunctions.LANG;}
      break;
    case NUMBERFUNC:
      jj_consume_token(NUMBERFUNC);
                  {if (true) return XPathFunctions.NUMBER;}
      break;
    case SUM:
      jj_consume_token(SUM);
           {if (true) return XPathFunctions.SUM;}
      break;
    case FLOOR:
      jj_consume_token(FLOOR);
             {if (true) return XPathFunctions.FLOOR;}
      break;
    case CEILING:
      jj_consume_token(CEILING);
               {if (true) return XPathFunctions.CEILING;}
      break;
    case ROUND:
      jj_consume_token(ROUND);
             {if (true) return XPathFunctions.ROUND;}
      break;
    default:
      jj_la1[83] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public XPathFunction XPathUserFunctionCallName() throws ParseException {
 Token t; setPredicateComplex();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MINUS_FUNC:
      jj_consume_token(MINUS_FUNC);
                 {if (true) return XPathFunctions.MINUS_FUNC;}
      break;
    case PLUS_FUNC:
      jj_consume_token(PLUS_FUNC);
                 {if (true) return XPathFunctions.PLUS_FUNC;}
      break;
    case SUBSTRINGBEFOREREVERSE:
      jj_consume_token(SUBSTRINGBEFOREREVERSE);
                              {if (true) return XPathFunctions.SUBSTRINGBEFOREREVERSE;}
      break;
    case SUBSTRINGAFTERREVERSE:
      jj_consume_token(SUBSTRINGAFTERREVERSE);
                             {if (true) return XPathFunctions.SUBSTRINGAFTERREVERSE;}
      break;
    case SUBSTRINGREVERSE:
      jj_consume_token(SUBSTRINGREVERSE);
                        {if (true) return XPathFunctions.SUBSTRINGREVERSE;}
      break;
    case REPLACE:
      jj_consume_token(REPLACE);
               {if (true) return XPathFunctions.REPLACE;}
      break;
    case STRINGJOIN:
      jj_consume_token(STRINGJOIN);
                  {if (true) return XPathFunctions.STRINGJOIN;}
      break;
    case CURRENTURL:
      jj_consume_token(CURRENTURL);
                  {if (true) return XPathFunctions.CURRENTURL;}
      break;
    case PAGECONTENT:
      jj_consume_token(PAGECONTENT);
                   {if (true) return XPathFunctions.PAGECONTENT;}
      break;
    case SCREENSHOT:
      jj_consume_token(SCREENSHOT);
                  {if (true) return XPathFunctions.SCREENSHOT;}
      break;
    case SAVEPAGE:
      jj_consume_token(SAVEPAGE);
                {if (true) return XPathFunctions.SAVEPAGE;}
      break;
    case NOW:
      jj_consume_token(NOW);
           {if (true) return XPathFunctions.NOW;}
      break;
    case URIFY:
      jj_consume_token(URIFY);
             {if (true) return XPathFunctions.URIFY;}
      break;
    case JAROWRINKLER:
      jj_consume_token(JAROWRINKLER);
                    {if (true) return XPathFunctions.JAROWRINKLER;}
      break;
    case QUALIFYURL:
      jj_consume_token(QUALIFYURL);
                  {if (true) return XPathFunctions.QUALIFYURL;}
      break;
    case DOMPROPERTY:
      jj_consume_token(DOMPROPERTY);
                   {if (true) return XPathFunctions.DOMPROPERTY;}
      break;
    case SELECTTEXT:
      jj_consume_token(SELECTTEXT);
                  {if (true) return XPathFunctions.SELECTTEXT;}
      break;
    case INNERHTML:
      jj_consume_token(INNERHTML);
                {if (true) return XPathFunctions.INNERHTML;}
      break;
    case OUTERHTML:
      jj_consume_token(OUTERHTML);
                {if (true) return XPathFunctions.OUTERHTML;}
      break;
    case TOXML:
      jj_consume_token(TOXML);
            {if (true) return XPathFunctions.TOXML;}
      break;
    case ISVISIBLE:
      jj_consume_token(ISVISIBLE);
                 {if (true) return XPathFunctions.ISVISIBLE;}
      break;
    case ISINVISIBLE:
      jj_consume_token(ISINVISIBLE);
                   {if (true) return XPathFunctions.ISINVISIBLE;}
      break;
    default:
      jj_la1[84] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void XPathArgument() throws ParseException {
    XPathExpr();
  }

  final public void XPathUnionExpr() throws ParseException {
 /*@bgen(jjtree) #BinaryOpExpr(> 1) */
  ASTBinaryOpExpr jjtn000 = new ASTBinaryOpExpr(JJTBINARYOPEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      XPathPathExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNION:
        jj_consume_token(UNION);
   jjtn000.setBinaryOperator(HigherLevelOp.UNION);
        XPathUnionExpr();
        break;
      default:
        jj_la1[85] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

// * The WARNING generated by the ambiguity in this rule is purposeful; the default (first rule condition satisfied) is what we always want.
// * This is because we restrict Kleene-Stars that begin with path expressions to start with / or // (in this way, no relative expressions can start with Kleene stars).
// * This restriction is necessary so as to save arbitrary lookahead as an entire unbounded relative OXPath expression must be parsed to determine if an operator and new expression occur afterwards.
// * This restriction results in no loss of expressivity.  Simply use ./(Kleene-star-expr)* in order to preserve context.
// * We treat the additional OXPath "step" feature - user actions - similiarly.
// * The LOOKAHEAD(1) is to simply suppress the warning; lets JavaCC know that the ambiguity was a deliberate choice.
  final public void XPathPathExpr() throws ParseException {
 /*@bgen(jjtree) #XPathPathExpr(> 1) */
  ASTXPathPathExpr jjtn000 = new ASTXPathPathExpr(JJTXPATHPATHEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PARAN:
      case NUMBER:
      case POSITION:
      case LAST:
      case COUNT:
      case ID:
      case NAMESPACEURI:
      case LOCALNAME:
      case NAME:
      case STRING:
      case CONCAT:
      case STARTSWITH:
      case CONTAINSFUNC:
      case MINUS_FUNC:
      case PLUS_FUNC:
      case SUBSTRINGBEFORE:
      case SUBSTRINGAFTER:
      case SUBSTRING:
      case SUBSTRINGLENGTH:
      case NORMALIZESPACE:
      case TRANSLATE:
      case SUBSTRINGBEFOREREVERSE:
      case SUBSTRINGAFTERREVERSE:
      case SUBSTRINGREVERSE:
      case STRINGJOIN:
      case REPLACE:
      case QUALIFYURL:
      case ISVISIBLE:
      case ISINVISIBLE:
      case TOXML:
      case DOMPROPERTY:
      case SELECTTEXT:
      case INNERHTML:
      case OUTERHTML:
      case CURRENTURL:
      case PAGECONTENT:
      case SCREENSHOT:
      case SAVEPAGE:
      case NOW:
      case URIFY:
      case JAROWRINKLER:
      case BOOLEAN:
      case NOT:
      case TRUE:
      case FALSE:
      case LANG:
      case NUMBERFUNC:
      case SUM:
      case FLOOR:
      case CEILING:
      case ROUND:
      case DIGITS:
      case DOUBLE_QUOTE_STRING_PATH:
      case SINGLE_QUOTE_STRING_PATH:
        XPathPrimaryExpr();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_OPTIONAL:
        case OPEN_BRACKET:
        case DESCENDENT_OR_SELF_SHORT:
        case SLASH:
        case BEGIN_EXTRACT_MARK:
        case PERIOD_OP:
        case HASH:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DESCENDENT_OR_SELF_SHORT:
          case SLASH:
            SimpleOXPathStepTail(null);
            break;
          case OPEN_OPTIONAL:
          case OPEN_BRACKET:
          case BEGIN_EXTRACT_MARK:
          case PERIOD_OP:
          case HASH:
            OXPathPostStepListOrPredicate();
            break;
          default:
            jj_la1[86] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                                                                                         jjtn000.setHasSimpleList(true);
          break;
        default:
          jj_la1[87] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOC_BEGIN:
        case BEGIN_URL_IN_PATH:
        case BEGIN_USER_ACTION:
        case BEGIN_KLEENE_STAR:
          ComplexOXPathStepPath();
                                                                                                                                                       jjtn000.setHasComplexList(true);
          break;
        default:
          jj_la1[88] = jj_gen;
          ;
        }
        break;
      case DOC_BEGIN:
      case BEGIN_URL_IN_PATH:
      case DESCENDENT_OR_SELF_SHORT:
      case BEGIN_USER_ACTION:
      case BEGIN_KLEENE_STAR:
      case SLASH:
      case STYLE:
      case ATTRIBUTE:
      case CHILD:
      case DESCENDANTORSELF:
      case DESCENDANT:
      case FOLLOWINGSIBLING:
      case FOLLOWING:
      case NAMESPACE:
      case SELF:
      case ANCESTORORSELF:
      case ANCESTOR:
      case PARENT:
      case PRECEDINGSIBLING:
      case PRECEDING:
      case COMMENT:
      case TEXT:
      case PROCESSING_INSTRUCTION:
      case NODE:
      case FIELD:
      case ANY_FIELD:
      case PERIOD:
      case PARENT_SHORT:
      case AT:
      case WILDCARD:
      case NCNAME:
        OXPathPathSegment();
        break;
      default:
        jj_la1[89] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
   }
    }
  }

//here, we restrict the Complex steps similiarly so that //ComplexOXPathStepPath isn't possible.
//as with the restriction of the relative OXPath location path beginning with a complex step, this restriction
//makes a cleaner semantics, a much more efficient parser (we remain at LL(1)), and no loss of expressivity (as
//this can be simulated with //*/ComplexOXPathStepPath
  final public void AbbreviatedAbsoluteOXPathLocationPath() throws ParseException {
 /*@bgen(jjtree) RelativeOXPathLocationPath */
  ASTRelativeOXPathLocationPath jjtn000 = new ASTRelativeOXPathLocationPath(JJTRELATIVEOXPATHLOCATIONPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      SimpleOXPathDOSStepPath(null);
                                 jjtn000.setHasSimplePath(true);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOC_BEGIN:
      case BEGIN_URL_IN_PATH:
      case BEGIN_USER_ACTION:
      case BEGIN_KLEENE_STAR:
        ComplexOXPathStepPath();
                            jjtn000.setHasComplexPath(true);
        break;
      default:
        jj_la1[90] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public Step AbbreviatedStep() throws ParseException {
 Step s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PERIOD:
      s = AbbreviatedSelfStep();
      break;
    case PARENT_SHORT:
      s = AbbreviatedParentStep();
      break;
    default:
      jj_la1[91] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
 {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public Step AbbreviatedSelfStep() throws ParseException {
    jj_consume_token(PERIOD);
              {if (true) return AbbreviatedStep.SELF;}
    throw new Error("Missing return statement in function");
  }

  final public Step AbbreviatedParentStep() throws ParseException {
    jj_consume_token(PARENT_SHORT);
                    {if (true) return AbbreviatedStep.PARENT;}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public OXPathParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[92];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
      jj_la1_init_5();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x20000000,0x40000000,0x0,0x0,0x80000006,0x80000006,0x80000006,0x80000000,0x6,0x0,0x20000000,0x80000006,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7ffff80,0x0,0x0,0x0,0x0,0x3ffff80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x6000,0x0,0x0,0x0,0xe000,0xffff,0xffff,0xffff,0xdf,0x1f00,0x8000,0x0,0xffff,0xc1040000,0xc1040000,0xe1040000,0xc1040000,0xc1040000,0x20000000,0xc1040000,0x0,0xe1040000,0x8000000,0xe1040000,0xe1040000,0x0,0x20600000,0x20600000,0x0,0x0,0x0,0x200000,0x600000,0x0,0x0,0x0,0x0,0x0,0x20600000,0x20600000,0x0,0x0,0x0,0x0,0x0,0x20600000,0x20600000,0x20600000,0x20600000,0x41040000,0x400000,0x8000000,0x1040000,0x0,0x400000,0x0,0x8000000,0x0,0x0,0x8000000,0x0,0x80000,0x80000,0x0,0x20600000,0x20600000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10080000,0x10000000,0x0,0x8000000,0xf10c0000,0x0,0x0,0x0,0x20600000,0x20600000,0xc1040000,0xf10c0000,0xc1040000,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fdfffa,0x0,0x7fdfff8,0x2,0x0,0x1,0x2,0x0,0x2,0x2,0x7fdfff8,0x6,0x6,0x401fff8,0x401fff8,0xfc0000,0x4,0x4,0xff0,0x1f000,0x0,0x3c0000,0xc00000,0x6,0x6,0x0,0x0,0x0,0x0,0x0,0x6,0x6,0x6,0x6,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6,0x6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf8000000,0x0,0xf8000000,0x0,0xfffdfffa,0xf8000000,0x0,0x0,0x6,0x6,0x0,0xfffdfffa,0x0,0x3000000,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfff7ffff,0x0,0xfff7ffff,0x0,0xfff7ffff,0x3f3f,0xfff7c0c0,0x0,0x0,0x0,0x0,0xfff7ffff,0x0,0x0,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x60000000,0x60000000,0x0,0x0,0x0,0x0,0x60000000,0x0,0x0,0x0,0x0,0x0,0x60000000,0x60000000,0x60000000,0x0,0x0,0x0,0x0,0x60000000,0x60000000,0x60000000,0x60000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x10000000,0x10000000,0x4002000,0x60000000,0x60000000,0x0,0x10000,0x8000,0x98000000,0x98000000,0x7800000,0x7800000,0x600000,0x600000,0xe0000,0xe0000,0x4000,0x1fff,0x0,0x1fff,0x0,0x5fff,0x1ff8,0x7,0x100000,0x60000000,0x60000000,0x0,0x1fff,0x0,0x0,};
   }
   private static void jj_la1_init_5() {
      jj_la1_5 = new int[] {0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60,0x0,0x60,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60,0x0,0x0,0x0,0x0,0x60,0x0,0x0,0x0,0x0,0x4800,0x60,0x0,0x0,0x0,0x0,0x60,0x100,0x60,0x4800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4a00,0x0,0x0,0x0,0xa,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4a00,0x200,0x0,0x0,0x4a60,0x0,0x0,0x0,0x0,0x0,0x0,0x4a60,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public OXPathParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public OXPathParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new OXPathParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 92; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 92; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public OXPathParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new OXPathParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 92; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 92; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public OXPathParser(OXPathParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 92; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(OXPathParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 92; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[176];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 92; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 176; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
